# 9、集成与扩展

本文档深入分析LAST-doc系统的外部接口、系统集成、扩展机制和开放性设计，为开发者提供全面的集成和扩展指南。

## 目录

- [RESTful API接口](#integration-rest-api)
- [gRPC服务集成](#integration-grpc)
- [OpenAI API集成](#integration-openai)
- [PostgreSQL集成](#integration-postgresql)
- [MinIO对象存储集成](#integration-minio)
- [监控系统集成](#integration-monitoring)
- [插件扩展机制](#extension-plugin)

---

## integration-rest-api {#integration-rest-api}

### RESTful API接口设计

LAST-doc系统采用RESTful架构风格，通过[`internal/router/router.go`](internal/router/router.go)实现统一的API路由管理。

#### 路由架构设计

系统使用Gin框架构建RESTful API，采用模块化路由设计：

```go
// Router 路由器结构
type Router struct {
    documentHandler   *handler.DocumentHandler
    searchHandler     *handler.SearchHandler
    aiFormatHandler   *handler.AIFormatHandler
    mcpHandler        *handler.MCPHandler
    userHandler       *handler.UserHandler
    monitorHandler    *handler.MonitorHandler
    healthHandler     *handler.HealthHandler
    backupHandler     *handler.BackupHandler
    metricsHandler    *handler.MetricsHandler
    authMiddleware    *middleware.AuthMiddleware
    loggingMiddleware *middleware.LoggingMiddleware
}
```

#### API版本控制

系统采用URL路径版本控制策略：

```go
// API版本分组
v1 := router.Group("/api/v1")
{
    // 所有API端点都在v1分组下
}
```

当前版本为`v1`，所有API端点都位于`/api/v1`路径下，为未来的API升级提供了清晰的版本管理基础。

#### 核心API端点

##### 1. 健康检查端点

用于Kubernetes探针和服务监控：

```go
// 健康检查路由（用于Kubernetes探针）
router.GET("/health", r.healthHandler.CheckHealth)
router.GET("/health/live", r.healthHandler.LivenessProbe)
router.GET("/health/ready", r.healthHandler.ReadinessProbe)
router.GET("/health/circuit-breakers", r.healthHandler.CircuitBreakers)
```

- **`/health`**: 综合健康检查
- **`/health/live`**: 存活探针（Liveness Probe）
- **`/health/ready`**: 就绪探针（Readiness Probe）
- **`/health/circuit-breakers`**: 熔断器状态检查

##### 2. Prometheus Metrics端点

```go
// Prometheus metrics 端点
router.GET("/metrics", r.metricsHandler.ServeMetrics)
```

暴露Prometheus格式的监控指标，详见[监控系统集成](#integration-monitoring)章节。

##### 3. 文档管理API

```go
documents := v1.Group("/documents")
{
    documents.POST("", r.documentHandler.UploadDocument)              // 上传文档
    documents.GET("", r.documentHandler.GetDocuments)                // 获取文档列表
    documents.GET("/:id", r.documentHandler.GetDocument)            // 获取指定文档
    documents.PUT("/:id", r.documentHandler.UpdateDocument)         // 更新文档
    documents.DELETE("/:id", r.documentHandler.DeleteDocument)       // 删除文档
    documents.GET("/:id/versions", r.documentHandler.GetDocumentVersions)           // 获取文档版本列表
    documents.GET("/:id/versions/latest", r.documentHandler.GetLatestVersion)      // 获取最新版本
    documents.GET("/:id/versions/:version", r.documentHandler.GetDocumentByVersion) // 获取指定版本
    documents.PUT("/:id/versions/:version", r.documentHandler.UpdateDocumentVersion) // 更新版本
    documents.DELETE("/:id/versions/:version", r.documentHandler.DeleteDocumentVersion) // 删除版本
    documents.GET("/:id/download", r.documentHandler.DownloadDocument)               // 下载文档
    documents.GET("/:id/metadata", r.documentHandler.GetDocumentMetadata)           // 获取元数据
    documents.GET("/:id/versions/:version/download", r.documentHandler.DownloadDocumentVersion) // 下载版本
    documents.POST("/build-missing-indexes", r.documentHandler.BuildAllMissingIndexes) // 构建缺失索引
}
```

**RESTful设计原则**：
- 使用HTTP动词表示操作：POST（创建）、GET（查询）、PUT（更新）、DELETE（删除）
- 使用资源路径表示操作对象：`/documents`、`/documents/:id/versions`
- 层次化URL路径表示资源关系：文档→版本→下载

##### 4. 搜索API

```go
search := v1.Group("/search")
{
    search.POST("", r.searchHandler.Search)                                          // 搜索文档(POST)
    search.GET("", r.searchHandler.SearchGet)                                        // 搜索文档(GET)
    search.POST("/documents/:id/versions/:version/index", r.searchHandler.BuildIndex) // 构建索引
    search.GET("/documents/:id/index/status", r.searchHandler.GetIndexingStatus)     // 获取索引状态
    search.DELETE("/documents/:id/index", r.searchHandler.DeleteIndex)              // 删除索引
    search.DELETE("/documents/:id/versions/:version/index", r.searchHandler.DeleteIndexByVersion) // 删除版本索引
}
```

##### 5. AI友好格式API

```go
aiFormat := v1.Group("/ai-format")
{
    aiFormat.GET("/documents/:id/versions/:version/structured", r.aiFormatHandler.StructuredContent) // 结构化内容
    aiFormat.POST("/documents/:id/versions/:version/llm", r.aiFormatHandler.GenerateLLMFormat)      // LLM优化格式
    aiFormat.GET("/documents/:id/versions/:version/multigranularity", r.aiFormatHandler.GenerateMultiGranularityRepresentation) // 多粒度表示
    aiFormat.POST("/documents/:id/versions/:version/context", r.aiFormatHandler.InjectContext)     // 注入上下文
    aiFormat.GET("/documents/:id/versions/:version", r.aiFormatHandler.GetAIFriendlyFormats)         // 获取AI格式列表
}
```

##### 6. MCP协议API

```go
router.POST("/mcp", r.mcpHandler.HandleMCPRequest)
router.GET("/mcp", r.mcpHandler.SendMessage) // 也支持GET方式

mcp := v1.Group("/mcp")
{
    mcp.GET("/config", r.mcpHandler.GetMCPConfig)         // 获取MCP配置
    mcp.GET("/test", r.mcpHandler.TestMCPConnection)       // 测试MCP连接
    
    keys := mcp.Group("/keys")
    keys.Use(r.authMiddleware.RequireAuth()) // 需要认证
    {
        keys.POST("", r.mcpHandler.CreateAPIKey)    // 创建API密钥
        keys.GET("", r.mcpHandler.GetAPIKeys)       // 获取API密钥列表
        keys.DELETE("/:id", r.mcpHandler.DeleteAPIKey) // 删除API密钥
    }
}
```

##### 7. 用户认证API

```go
auth := v1.Group("/auth")
{
    auth.POST("/register", r.userHandler.Register)                           // 用户注册
    auth.POST("/login", r.userHandler.Login)                                 // 用户登录
    auth.POST("/refresh", r.userHandler.RefreshToken)                        // 刷新令牌
    auth.POST("/password/reset-request", r.userHandler.RequestPasswordReset)  // 请求密码重置
    auth.POST("/password/reset", r.userHandler.ResetPassword)                // 重置密码
}
```

##### 8. 用户管理API

```go
users := v1.Group("/users")
users.Use(r.authMiddleware.RequireAuth()) // 需要认证
{
    // 当前用户信息
    users.GET("/profile", r.userHandler.GetProfile)
    users.PUT("/profile", r.userHandler.UpdateProfile)
    users.POST("/change-password", r.userHandler.ChangePassword)
    
    // 管理员功能
    admin := users.Group("")
    admin.Use(r.authMiddleware.RequireAdmin()) // 需要管理员权限
    {
        admin.GET("", r.userHandler.ListUsers)      // 列出所有用户
        admin.GET("/:id", r.userHandler.GetUser)     // 获取用户详情
        admin.PUT("/:id", r.userHandler.UpdateUser)  // 更新用户
        admin.DELETE("/:id", r.userHandler.DeleteUser) // 删除用户
    }
}
```

##### 9. 系统监控API

```go
monitor := v1.Group("/monitor")
monitor.Use(r.authMiddleware.RequireAuth())  // 需要认证
monitor.Use(r.authMiddleware.RequireAdmin()) // 需要管理员权限
{
    monitor.GET("/metrics/current", r.monitorHandler.GetCurrentMetrics)       // 获取当前指标
    monitor.GET("/metrics/history", r.monitorHandler.GetMetricsHistory)       // 获取历史指标
    monitor.GET("/metrics/report", r.monitorHandler.GetMetricsReport)       // 获取指标报告
    monitor.GET("/status", r.monitorHandler.GetSystemStatus)                // 获取系统状态
    monitor.GET("/logs", r.monitorHandler.GetLogs)                           // 获取日志列表
    monitor.GET("/logs/stats", r.monitorHandler.GetLogStats)                  // 获取日志统计
    monitor.GET("/performance", r.monitorHandler.GetPerformanceReport)        // 获取性能报告
    monitor.POST("/cleanup", r.monitorHandler.CleanupOldData)                // 清理旧数据
}
```

##### 10. 备份管理API

```go
backup := v1.Group("/backup")
backup.Use(r.authMiddleware.RequireAuth())  // 需要认证
backup.Use(r.authMiddleware.RequireAdmin()) // 需要管理员权限
{
    backup.POST("/create", r.backupHandler.CreateBackup)           // 创建备份
    backup.GET("/list", r.backupHandler.ListBackups)               // 获取备份列表
    backup.POST("/restore/:backupId", r.backupHandler.RestoreBackup) // 恢复备份
    backup.DELETE("/:backupId", r.backupHandler.DeleteBackup)       // 删除备份
}
```

#### 中间件设计

##### 1. 全局中间件

```go
func (r *Router) SetupRoutes() *gin.Engine {
    gin.SetMode(gin.ReleaseMode)
    router := gin.New()
    
    // 使用中间件
    router.Use(gin.Logger())                    // Gin日志中间件
    router.Use(gin.Recovery())                   // 恢复中间件
    router.Use(middleware.CORS())                // 跨域中间件
    router.Use(r.loggingMiddleware.LogRequest()) // 自定义日志记录中间件
```

##### 2. 认证中间件

参考[`internal/middleware/auth.go`](internal/middleware/auth.go)：

**RequireAuth**: 需要认证的中间件
```go
func (m *AuthMiddleware) RequireAuth() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 获取Authorization头
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "缺少授权令牌"})
            c.Abort()
            return
        }
        
        // 检查Bearer前缀
        if !strings.HasPrefix(authHeader, "Bearer ") {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "无效的授权格式"})
            c.Abort()
            return
        }
        
        // 提取令牌
        tokenString := authHeader[7:]
        
        // 验证令牌
        claims, err := m.userService.ValidateJWT(tokenString)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "无效的授权令牌"})
            c.Abort()
            return
        }
        
        // 将用户信息存储到上下文中
        c.Set("user_id", claims.UserID)
        c.Set("username", claims.Username)
        c.Set("role", claims.Role)
        
        c.Next()
    }
}
```

**RequireAdmin**: 需要管理员权限的中间件
```go
func (m *AuthMiddleware) RequireAdmin() gin.HandlerFunc {
    return m.RequireRole("admin")
}
```

**APIKeyAuth**: API密钥认证中间件
```go
func (m *AuthMiddleware) APIKeyAuth() gin.HandlerFunc {
    return func(c *gin.Context) {
        apiKey := c.GetHeader("API_KEY")
        if apiKey == "" {
            // 尝试从Authorization头获取
            authHeader := c.GetHeader("Authorization")
            if strings.HasPrefix(authHeader, "Bearer ") {
                apiKey = strings.TrimPrefix(authHeader, "Bearer ")
            }
        }
        
        if apiKey == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "API密钥是必需的"})
            c.Abort()
            return
        }
        
        c.Set("api_key", apiKey)
        c.Next()
    }
}
```

**OptionalAuth**: 可选认证中间件
```go
func (m *AuthMiddleware) OptionalAuth() gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.Next()
            return
        }
        
        // 如果提供了令牌，尝试验证
        if strings.HasPrefix(authHeader, "Bearer ") {
            tokenString := authHeader[7:]
            claims, err := m.userService.ValidateJWT(tokenString)
            if err == nil {
                c.Set("user_id", claims.UserID)
                c.Set("username", claims.Username)
                c.Set("role", claims.Role)
            }
        }
        
        c.Next()
    }
}
```

**CORS**: 跨域中间件
```go
func CORS() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Header("Access-Control-Allow-Origin", "*")
        c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization, API_KEY")
        c.Header("Access-Control-Max-Age", "86400")
        
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(204)
            return
        }
        
        c.Next()
    }
}
```

#### 请求处理流程

1. **请求到达**: 客户端发送HTTP请求到API端点
2. **全局中间件**: 执行全局中间件链（日志、恢复、CORS、自定义日志）
3. **路由中间件**: 执行特定路由的中间件（认证、权限验证）
4. **Handler处理**: 调用相应的Handler处理业务逻辑
5. **响应返回**: 返回JSON格式的响应

#### 响应格式

系统使用统一的JSON响应格式：

**成功响应**:
```json
{
  "data": { ... },
  "message": "success"
}
```

**错误响应**:
```json
{
  "error": "错误描述",
  "code": "ERROR_CODE"
}
```

#### 参数验证

系统使用Gin的binding标签进行参数验证：

```go
type SearchRequest struct {
    Query      string                 `json:"query" binding:"required"`
    Filters    map[string]interface{} `json:"filters"`
    Page       int                    `json:"page" binding:"min=1"`
    Size       int                    `json:"size" binding:"min=1,max=100"`
    SearchType string                 `json:"searchType" binding:"required"`
}
```

#### 错误处理

系统采用统一的错误处理机制：

1. **HTTP状态码**: 使用标准HTTP状态码表示请求结果
   - 200: 成功
   - 201: 创建成功
   - 400: 请求参数错误
   - 401: 未授权
   - 403: 权限不足
   - 404: 资源未找到
   - 500: 服务器内部错误

2. **错误信息**: 错误响应包含详细的错误描述

---

## integration-grpc {#integration-grpc}

### gRPC服务集成

LAST-doc系统通过gRPC协议与Python文档解析服务进行通信，实现跨语言的文档解析能力。

#### Proto定义

根据[`proto/document_parser.proto`](proto/document_parser.proto)：

```protobuf
syntax = "proto3";

package document_parser;

option go_package = "/pb";

// 文档解析服务定义
service DocumentParserService {
  // 解析PDF文档
  rpc ParsePDF(ParsePDFRequest) returns (ParseDocumentResponse);
  
  // 解析DOCX文档
  rpc ParseDOCX(ParseDOCXRequest) returns (ParseDocumentResponse);
  
  // 健康检查
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);
}

// PDF解析请求
message ParsePDFRequest {
  string file_path = 1;
  bytes file_data = 2; // 可选：可以直接传递文件数据
}

// DOCX解析请求
message ParseDOCXRequest {
  string file_path = 1;
  bytes file_data = 2; // 可选：可以直接传递文件数据
}

// 文档解析响应
message ParseDocumentResponse {
  bool success = 1;
  string content = 2;
  map<string, string> metadata = 3;
  string error_message = 4;
}

// 健康检查请求
message HealthCheckRequest {
  string service = 1;
}

// 健康检查响应
message HealthCheckResponse {
  bool healthy = 1;
  string message = 2;
  string version = 3;
}
```

**服务特点**：
- 支持PDF和DOCX文档解析
- 支持通过文件路径或文件数据两种方式传递文档
- 返回解析后的文本内容和元数据
- 提供健康检查接口

#### gRPC客户端实现

根据[`internal/service/grpc_client.go`](internal/service/grpc_client.go)：

##### 客户端结构

```go
// GRPCClient gRPC客户端
type GRPCClient struct {
    conn   *grpc.ClientConn
    client pb.DocumentParserServiceClient
}
```

##### 连接管理

```go
// NewGRPCClient 创建gRPC客户端
func NewGRPCClient() *GRPCClient {
    return &GRPCClient{}
}

// Connect 连接到gRPC服务器
func (c *GRPCClient) Connect(serverAddr string) error {
    var err error
    
    // 连接到解析服务
    c.conn, err = grpc.Dial(serverAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
    if err != nil {
        log.Printf("DEBUG: gRPC连接失败 - 服务地址: %s, 错误: %v", serverAddr, err)
        return fmt.Errorf("连接解析服务失败: %v", err)
    }
    
    // 创建客户端实例
    c.client = pb.NewDocumentParserServiceClient(c.conn)
    
    log.Printf("DEBUG: gRPC客户端连接成功 - 服务地址: %s", serverAddr)
    return nil
}

// Close 关闭连接
func (c *GRPCClient) Close() {
    if c.conn != nil {
        c.conn.Close()
    }
}
```

**连接特点**：
- 使用不安全的连接（insecure credentials），适用于内网环境
- 可通过环境变量配置服务器地址
- 提供连接关闭方法释放资源

##### PDF解析

```go
// ParsePDFWithGRPC 通过gRPC调用Python服务解析PDF
func (c *GRPCClient) ParsePDFWithGRPC(filePath string) (string, map[string]interface{}, error) {
    // 获取当前工作目录和绝对路径用于诊断
    currentDir, _ := os.Getwd()
    absPath, _ := filepath.Abs(filePath)
    log.Printf("DEBUG: 通过gRPC调用Python服务解析PDF - Go工作目录: %s", currentDir)
    log.Printf("DEBUG: 通过gRPC调用Python服务解析PDF - 原始路径: %s", filePath)
    log.Printf("DEBUG: 通过gRPC调用Python服务解析PDF - 绝对路径: %s", absPath)
    
    if c.client == nil {
        return "", nil, fmt.Errorf("gRPC客户端未连接")
    }
    
    // 创建带超时的上下文
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    // 调用gRPC服务，使用绝对路径
    req := &pb.ParsePDFRequest{FilePath: absPath}
    resp, err := c.client.ParsePDF(ctx, req)
    if err != nil {
        log.Printf("DEBUG: gRPC PDF解析失败 - 原始路径: %s, 绝对路径: %s, 错误: %v", filePath, absPath, err)
        return "", nil, fmt.Errorf("gRPC PDF解析失败: %v", err)
    }
    
    if !resp.Success {
        return "", nil, fmt.Errorf("PDF解析服务返回错误: %s", resp.ErrorMessage)
    }
    
    // 转换元数据格式
    metadata := make(map[string]interface{})
    for k, v := range resp.Metadata {
        metadata[k] = v
    }
    
    // 检查返回的内容是否包含非UTF-8字符
    content := resp.Content
    isValidUTF8 := true
    for i, r := range content {
        if r == utf8.RuneError {
            _, size := utf8.DecodeRuneInString(content[i:])
            if size == 1 {
                isValidUTF8 = false
                break
            }
        }
    }
    
    // 安全地输出内容预览，避免乱码
    if isValidUTF8 {
        preview := content
        if len(preview) > 100 {
            preview = preview[:100] + "..."
        }
        log.Printf("DEBUG: gRPC PDF解析完成 - 文件路径: %s, 内容长度: %d", filePath, len(content))
        log.Printf("DEBUG: PDF内容预览: %q", preview)
    } else {
        log.Printf("DEBUG: gRPC PDF解析完成 - 文件路径: %s, 内容长度: %d, 内容包含非UTF-8字符", filePath, len(content))
    }
    
    return content, metadata, nil
}
```

**实现特点**：
- 使用绝对路径传递文件，避免路径问题
- 设置30秒超时，防止长时间阻塞
- 详细的日志记录，便于调试
- UTF-8字符验证，确保内容安全
- 自动转换元数据格式

##### DOCX解析

```go
// ParseDOCXWithGRPC 通过gRPC调用Python服务解析DOCX
func (c *GRPCClient) ParseDOCXWithGRPC(filePath string) (string, map[string]interface{}, error) {
    // 获取当前工作目录和绝对路径用于诊断
    currentDir, _ := os.Getwd()
    absPath, _ := filepath.Abs(filePath)
    log.Printf("DEBUG: 通过gRPC调用Python服务解析DOCX - Go工作目录: %s", currentDir)
    log.Printf("DEBUG: 通过gRPC调用Python服务解析DOCX - 原始路径: %s", filePath)
    log.Printf("DEBUG: 通过gRPC调用Python服务解析DOCX - 绝对路径: %s", absPath)
    
    if c.client == nil {
        return "", nil, fmt.Errorf("gRPC客户端未连接")
    }
    
    // 创建带超时的上下文
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    // 调用gRPC服务，使用绝对路径
    req := &pb.ParseDOCXRequest{FilePath: absPath}
    resp, err := c.client.ParseDOCX(ctx, req)
    if err != nil {
        log.Printf("DEBUG: gRPC DOCX解析失败 - 原始路径: %s, 绝对路径: %s, 错误: %v", filePath, absPath, err)
        return "", nil, fmt.Errorf("gRPC DOCX解析失败: %v", err)
    }
    
    if !resp.Success {
        return "", nil, fmt.Errorf("DOCX解析服务返回错误: %s", resp.ErrorMessage)
    }
    
    // 转换元数据格式
    metadata := make(map[string]interface{})
    for k, v := range resp.Metadata {
        metadata[k] = v
    }
    
    // 检查返回的内容是否包含非UTF-8字符
    content := resp.Content
    isValidUTF8 := true
    for i, r := range content {
        if r == utf8.RuneError {
            _, size := utf8.DecodeRuneInString(content[i:])
            if size == 1 {
                isValidUTF8 = false
                break
            }
        }
    }
    
    // 安全地输出内容预览，避免乱码
    if isValidUTF8 {
        preview := content
        if len(preview) > 100 {
            preview = preview[:100] + "..."
        }
        log.Printf("DEBUG: gRPC DOCX解析完成 - 文件路径: %s, 内容长度: %d", filePath, len(content))
        log.Printf("DEBUG: DOCX内容预览: %q", preview)
    } else {
        log.Printf("DEBUG: gRPC DOCX解析完成 - 文件路径: %s, 内容长度: %d, 内容包含非UTF-8字符", filePath, len(content))
    }
    
    return content, metadata, nil
}
```

##### 健康检查

```go
// HealthCheck 健康检查
func (c *GRPCClient) HealthCheck(service string) (bool, string, error) {
    log.Printf("DEBUG: 执行健康检查 - 服务: %s", service)
    
    if c.client == nil {
        return false, "gRPC客户端未连接", nil
    }
    
    // 创建带超时的上下文
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    // 调用健康检查
    req := &pb.HealthCheckRequest{Service: service}
    resp, err := c.client.HealthCheck(ctx, req)
    if err != nil {
        log.Printf("DEBUG: 健康检查失败 - 服务: %s, 错误: %v", service, err)
        return false, fmt.Sprintf("健康检查失败: %v", err), nil
    }
    
    return resp.Healthy, resp.Message, nil
}
```

#### 解析服务集成

根据[`internal/service/parser_service.go`](internal/service/parser_service.go)：

##### 解析服务结构

```go
// parserService 解析服务实现
type parserService struct {
    parsers    map[model.DocumentType]DocumentParser
    grpcClient *GRPCClient
}
```

##### 解析服务初始化

```go
// NewParserService 创建解析服务实例
func NewParserService() DocumentParserService {
    service := &parserService{
        parsers:    make(map[model.DocumentType]DocumentParser),
        grpcClient: NewGRPCClient(),
    }
    
    // 注册各种文档类型的解析器
    service.RegisterParser(model.DocumentTypeMarkdown, NewMarkdownParser())
    service.RegisterParser(model.DocumentTypeSwagger, NewSwaggerParser())
    service.RegisterParser(model.DocumentTypeOpenAPI, NewOpenAPIParser())
    service.RegisterParser(model.DocumentTypeJavaDoc, NewJavaDocParser())
    
    // 从环境变量获取 gRPC 服务器地址
    grpcHost := os.Getenv("GRPC_SERVER_HOST")
    grpcPort := os.Getenv("GRPC_SERVER_PORT")
    
    if grpcHost == "" {
        grpcHost = "localhost"
    }
    if grpcPort == "" {
        grpcPort = "50051"
    }
    
    grpcAddr := grpcHost + ":" + grpcPort
    
    // 连接到gRPC服务
    if err := service.grpcClient.Connect(grpcAddr); err != nil {
        fmt.Printf("警告：连接gRPC服务失败(%s)，将使用本地解析器: %v\n", grpcAddr, err)
        // 如果连接失败，回退到本地解析器
        service.RegisterParser(model.DocumentTypePDF, NewPDFParser())
        service.RegisterParser(model.DocumentTypeDocx, NewDocxParser())
    } else {
        // 连接成功，使用gRPC解析器
        service.RegisterParser(model.DocumentTypePDF, NewPDFGRPCParser(service.grpcClient))
        service.RegisterParser(model.DocumentTypeDocx, NewDocxGRPCParser(service.grpcClient))
    }
    
    return service
}
```

**集成特点**：
- 优雅的降级机制：gRPC连接失败时自动回退到本地解析器
- 灵活的配置：通过环境变量配置服务器地址
- 统一的接口：所有解析器实现相同的`DocumentParser`接口
- 动态注册：支持运行时注册新的解析器

#### 通信协议特性

##### 1. 性能优势

- **二进制序列化**: 使用Protocol Buffers二进制格式，比JSON更高效
- **HTTP/2传输**: 支持多路复用，减少连接开销
- **流式通信**: 支持双向流式数据传输

##### 2. 可靠性

- **强类型接口**: Proto定义确保类型安全
- **自动重试**: 支持自动重试机制
- **超时控制**: 通过context控制请求超时

##### 3. 可扩展性

- **版本兼容**: Proto支持版本演进
- **多语言支持**: 可生成多语言客户端代码
- **服务发现**: 可集成服务发现机制

#### 错误处理

系统实现了完善的gRPC错误处理机制：

1. **连接失败**: 自动回退到本地解析器
2. **解析失败**: 返回详细的错误信息
3. **超时处理**: 设置合理的超时时间
4. **日志记录**: 详细的调试日志

---

## integration-openai {#integration-openai}

### OpenAI API集成

LAST-doc系统集成了OpenAI Embedding API，用于生成文档的语义向量，实现语义搜索功能。

#### Embedding服务接口

根据[`internal/service/embedding_service.go`](internal/service/embedding_service.go)：

```go
// EmbeddingService 嵌入向量服务接口
type EmbeddingService interface {
    GenerateEmbedding(ctx context.Context, content string) ([]float32, error)
}
```

#### OpenAI实现

##### OpenAI服务结构

```go
// openAIEmbeddingService OpenAI 嵌入向量服务实现
type openAIEmbeddingService struct {
    client *openai.Client
    model  openai.EmbeddingModel
}
```

##### 服务初始化

```go
// NewOpenAIEmbeddingService 创建 OpenAI 嵌入向量服务实例
func NewOpenAIEmbeddingService(apiKey, modelStr string) EmbeddingService {
    // 如果未提供 API Key，尝试从环境变量获取
    if apiKey == "" {
        apiKey = os.Getenv("OPENAI_API_KEY")
    }
    
    // 如果仍未提供 API Key，使用空的客户端（用于测试或模拟）
    config := openai.DefaultConfig(apiKey)
    
    // 可以自定义 OpenAI API 基础 URL，以支持兼容的服务
    if baseURL := os.Getenv("OPENAI_BASE_URL"); baseURL != "" {
        config.BaseURL = baseURL
    }
    
    client := openai.NewClientWithConfig(config)
    
    // 默认模型
    var model openai.EmbeddingModel
    if modelStr == "" {
        model = openai.AdaEmbeddingV2
    } else {
        model = openai.EmbeddingModel(modelStr)
    }
    
    return &openAIEmbeddingService{
        client: client,
        model:  model,
    }
}
```

**配置特性**：
- 支持从参数或环境变量读取API密钥
- 支持自定义API基础URL（兼容兼容服务）
- 默认使用`text-embedding-ada-002`模型
- 可自定义Embedding模型

##### 向量生成

```go
// GenerateEmbedding 生成文本的嵌入向量
func (s *openAIEmbeddingService) GenerateEmbedding(ctx context.Context, content string) ([]float32, error) {
    // 检查内容是否为空
    if strings.TrimSpace(content) == "" {
        return nil, fmt.Errorf("content is empty")
    }
    
    // 截断过长的内容，OpenAI API 有输入限制
    if len(content) > 8192 {
        content = content[:8192]
        log.Printf("Warning: Content truncated to 8192 characters for embedding generation")
    }
    
    // 创建嵌入请求
    req := openai.EmbeddingRequest{
        Input: []string{content},
        Model: s.model,
    }
    
    // 调用 OpenAI API
    resp, err := s.client.CreateEmbeddings(ctx, req)
    if err != nil {
        log.Printf("Error generating embedding: %v", err)
        return nil, fmt.Errorf("failed to generate embedding: %v", err)
    }
    
    // 检查响应
    if len(resp.Data) == 0 {
        return nil, fmt.Errorf("no embedding data returned")
    }
    
    // 返回嵌入向量
    return resp.Data[0].Embedding, nil
}
```

**实现特点**：
- 内容长度限制：8192字符
- 错误处理：详细的错误日志
- 验证检查：确保响应有效

#### Mock实现

系统提供了Mock实现，用于测试或离线场景：

```go
// mockEmbeddingService 模拟嵌入向量服务实现（用于测试或当 OpenAI 服务不可用时）
type mockEmbeddingService struct{}

// NewMockEmbeddingService 创建模拟嵌入向量服务实例
func NewMockEmbeddingService() EmbeddingService {
    return &mockEmbeddingService{}
}

// GenerateEmbedding 生成模拟的文本嵌入向量
func (s *mockEmbeddingService) GenerateEmbedding(ctx context.Context, content string) ([]float32, error) {
    // 检查内容是否为空
    if strings.TrimSpace(content) == "" {
        return nil, fmt.Errorf("content is empty")
    }
    
    // 生成模拟的 384 维向量（与 sentence-transformers/all-MiniLM-L6-v2 的维度相同）
    vector := make([]float32, 384)
    
    // 使用简单哈希生成模拟向量
    for i := 0; i < len(vector); i++ {
        // 基于内容和位置生成伪随机值
        hash := simpleHash(fmt.Sprintf("%s-%d", content, i))
        // 转换为 -1 到 1 之间的浮点数
        vector[i] = float32(hash%1000)/500.0 - 1.0
    }
    
    // 归一化向量
    norm := float32(0)
    for _, v := range vector {
        norm += v * v
    }
    if norm > 0 {
        norm = sqrt(norm)
        for i := range vector {
            vector[i] /= norm
        }
    }
    
    return vector, nil
}
```

**Mock特点**：
- 生成384维向量（兼容常见模型）
- 基于内容的确定性哈希
- 向量归一化
- 可用于离线测试

#### 错误处理

系统实现了完善的错误处理机制：

1. **空内容检查**: 确保输入不为空
2. **长度限制**: 自动截断超长内容
3. **API错误**: 捕获并记录API错误
4. **响应验证**: 确保返回有效向量

#### 成本控制

为了控制API使用成本，系统实现了以下策略：

1. **内容长度限制**: 8192字符
2. **缓存机制**: 避免重复生成向量
3. **批量处理**: 支持批量生成（如果需要）
4. **Mock模式**: 支持离线测试

#### 配置说明

通过环境变量配置OpenAI集成：

```bash
# API密钥（必需）
OPENAI_API_KEY=sk-...

# API基础URL（可选，用于兼容服务）
OPENAI_BASE_URL=https://api.openai.com/v1

# 默认模型（可选，默认text-embedding-ada-002）
OPENAI_EMBEDDING_MODEL=text-embedding-ada-002
```

#### 扩展性

设计支持扩展到其他Embedding服务：

1. **接口抽象**: `EmbeddingService`接口
2. **多种实现**: OpenAI、Mock等
3. **易于切换**: 通过配置选择实现
4. **未来扩展**: 可添加其他服务（如Cohere、HuggingFace）

---

## integration-postgresql {#integration-postgresql}

### PostgreSQL集成

LAST-doc系统使用PostgreSQL作为主要的关系型数据库，集成了GORM ORM框架和pgvector扩展，支持向量存储和语义搜索。

#### 数据库架构

##### GORM集成

系统使用GORM作为ORM框架，提供类型安全的数据库操作：

```go
import (
    "gorm.io/gorm"
    "gorm.io/driver/postgres"
)

// 数据库连接
dsn := "host=localhost user=postgres password=postgres dbname=lastdoc port=5432 sslmode=disable TimeZone=Asia/Shanghai"
db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
```

##### pgvector扩展

系统集成了pgvector扩展，支持向量存储和相似度搜索：

**向量模型定义**（[`internal/model/search_index.go`](internal/model/search_index.go)）：

```go
// SearchIndex 定义搜索索引模型
type SearchIndex struct {
    ID          string    `json:"id" gorm:"primaryKey"`
    DocumentID  string    `json:"document_id" gorm:"not null;index"`
    Version     string    `json:"version" gorm:"not null;index"`
    Content     string    `json:"content" gorm:"type:text;not null"`
    ContentType string    `json:"content_type" gorm:"not null;index"` // text, code, etc.
    Section     string    `json:"section" gorm:"index"`               // 文档章节
    Keywords    string    `json:"keywords" gorm:"type:text"`          // 关键词
    Vector      string    `json:"vector" gorm:"type:jsonb"`           // 语义向量，以JSON字符串格式存储
    Embedding   []float32 `json:"embedding" gorm:"-"`                 // 真实嵌入向量，使用pgvector扩展
    Metadata    string    `json:"metadata" gorm:"type:jsonb"`         // 额外元数据
    Score       float32   `json:"score"`                              // 搜索相关度得分
    CreatedAt   time.Time `json:"created_at" gorm:"autoCreateTime"`
    UpdatedAt   time.Time `json:"updated_at" gorm:"autoUpdateTime"`
}
```

**向量类型定义**：

```go
// Vector 自定义类型，用于处理 jsonb 字段
type Vector []float32

// Value 实现 driver.Valuer 接口
func (v Vector) Value() (driver.Value, error) {
    if v == nil {
        return nil, nil
    }
    return json.Marshal(v)
}

// Scan 实现 sql.Scanner 接口
func (v *Vector) Scan(value interface{}) error {
    if value == nil {
        *v = nil
        return nil
    }
    
    bytes, ok := value.([]byte)
    if !ok {
        return errors.New("type assertion to []byte failed")
    }
    
    return json.Unmarshal(bytes, *v)
}
```

#### 数据库连接管理

##### 连接池配置

系统使用GORM的连接池管理数据库连接：

```go
sqlDB, err := db.DB()
if err != nil {
    panic("failed to get database connection")
}

// 连接池配置
sqlDB.SetMaxIdleConns(10)    // 最大空闲连接数
sqlDB.SetMaxOpenConns(100)   // 最大打开连接数
sqlDB.SetConnMaxLifetime(time.Hour) // 连接最大生命周期
```

##### 健康检查

系统实现了数据库健康检查机制：

```go
func (db *gorm.DB) HealthCheck() error {
    sqlDB, err := db.DB()
    if err != nil {
        return err
    }
    
    // 尝试ping数据库
    return sqlDB.Ping()
}
```

#### 事务处理

系统使用GORM的事务机制确保数据一致性：

```go
// 开始事务
tx := db.Begin()
if tx.Error != nil {
    return tx.Error
}

// 执行操作
if err := tx.Create(&index).Error; err != nil {
    tx.Rollback()
    return err
}

// 提交事务
if err := tx.Commit().Error; err != nil {
    return err
}
```

**批量事务处理示例**（[`internal/repository/search_index_repository.go`](internal/repository/search_index_repository.go)）：

```go
// CreateBatch 批量创建搜索索引
func (r *searchIndexRepository) CreateBatch(ctx context.Context, indices []*model.SearchIndex) error {
    log.Printf("DEBUG: CreateBatch called with %d indices", len(indices))
    if len(indices) == 0 {
        log.Printf("DEBUG: CreateBatch: no indices to create")
        return nil
    }
    
    // 手动处理批量插入，避免 GORM 的 JSON 序列化问题
    log.Printf("DEBUG: 开始事务处理批量插入")
    tx := r.db.WithContext(ctx).Begin()
    if tx.Error != nil {
        log.Printf("DEBUG: 开始事务失败: %v", tx.Error)
        return tx.Error
    }
    
    for i := 0; i < len(indices); i += 100 {
        end := i + 100
        if end > len(indices) {
            end = len(indices)
        }
        
        log.Printf("DEBUG: 处理批次 %d-%d，共 %d 个索引", i+1, end, end-i)
        batch := indices[i:end]
        values := make([]interface{}, 0, len(batch)*9)
        valueStrings := make([]string, 0, len(batch))
        
        for _, index := range batch {
            valueStrings = append(valueStrings, "(?, ?, ?, ?, ?, ?, ?, ?, ?)")
            values = append(values,
                index.ID,
                index.DocumentID,
                index.Version,
                index.Content,
                index.ContentType,
                index.Section,
                index.Keywords,
                index.Vector,
                index.Metadata,
            )
        }
        
        query := fmt.Sprintf("INSERT INTO search_indices (id, document_id, version, content, content_type, section, keywords, vector, metadata) VALUES %s",
            strings.Join(valueStrings, ","))
        
        log.Printf("DEBUG: 执行插入查询，参数数量: %d", len(values))
        if err := tx.Exec(query, values...).Error; err != nil {
            log.Printf("DEBUG: 批量插入失败: %v", err)
            tx.Rollback()
            return err
        }
        log.Printf("DEBUG: 批量插入成功，批次 %d-%d", i+1, end)
    }
    
    log.Printf("DEBUG: 提交事务")
    if err := tx.Commit().Error; err != nil {
        log.Printf("DEBUG: 提交事务失败: %v", err)
        return err
    }
    log.Printf("DEBUG: 批量创建索引完成，共 %d 个索引", len(indices))
    return nil
}
```

**批量处理特点**：
- 分批处理：每批100条记录
- 手动SQL构造：避免GORM的JSON序列化问题
- 事务保护：确保批量操作的原子性
- 详细日志：便于调试和监控

#### 索引优化

系统创建了大量索引以提高查询性能：

##### 搜索索引表索引

```sql
-- 主键索引
PRIMARY KEY (id)

-- 文档ID索引
CREATE INDEX idx_search_indices_document_id ON search_indices(document_id);

-- 版本索引
CREATE INDEX idx_search_indices_version ON search_indices(version);

-- 内容类型索引
CREATE INDEX idx_search_indices_content_type ON search_indices(content_type);

-- 章节索引
CREATE INDEX idx_search_indices_section ON search_indices(section);

-- 复合索引（文档ID + 版本）
CREATE INDEX idx_search_indices_doc_version ON search_indices(document_id, version);

-- 创建时间索引
CREATE INDEX idx_search_indices_created_at ON search_indices(created_at);
```

**索引设计原则**：
- 为常用查询字段创建索引
- 使用复合索引优化组合查询
- 避免过度索引影响写入性能
- 定期分析索引使用情况

#### 向量搜索

系统利用pgvector扩展实现向量相似度搜索：

##### 向量存储

向量以JSONB格式存储在数据库中：

```go
// 将向量转换为JSON字符串
vectorJSON, err := json.Marshal(vectorSlice)
if err != nil {
    log.Printf("Error marshaling vector to JSON: %v", err)
    vectorJSON = []byte("[]")
}

// 存储到数据库
index.Vector = string(vectorJSON)
```

##### 相似度查询

```sql
-- 使用pgvector的余弦相似度
SELECT * FROM search_indices
ORDER BY vector <=> '[0.1, 0.2, 0.3, ...]'::vector
LIMIT 10;
```

**查询优化**：
- 使用索引加速向量搜索
- 限制返回结果数量
- 结合其他过滤条件

#### 数据库分片

为支持大规模数据，系统设计了分片架构：

1. **水平分片**: 按文档ID分片
2. **垂直分片**: 热数据和冷数据分离
3. **读写分离**: 主从复制架构

#### 备份与恢复

系统提供了完善的备份机制：

##### 备份服务

参考[`internal/service/postgres_backup.go`](internal/service/postgres_backup.go)：

```go
// 创建备份
func (s *PostgresBackupService) CreateBackup(ctx context.Context) (*model.Backup, error) {
    // 执行pg_dump
    backupFile := fmt.Sprintf("backup_%s.sql", time.Now().Format("20060102_150405"))
    cmd := exec.Command("pg_dump", "-h", s.host, "-U", s.user, "-d", s.dbname, "-f", backupFile)
    
    if err := cmd.Run(); err != nil {
        return nil, fmt.Errorf("backup failed: %v", err)
    }
    
    return &model.Backup{
        ID:        generateID(),
        FileName:  backupFile,
        Size:      getFileSize(backupFile),
        CreatedAt: time.Now(),
    }, nil
}

// 恢复备份
func (s *PostgresBackupService) RestoreBackup(ctx context.Context, backupID string) error {
    // 获取备份文件
    backup, err := s.GetBackup(ctx, backupID)
    if err != nil {
        return err
    }
    
    // 执行恢复
    cmd := exec.Command("psql", "-h", s.host, "-U", s.user, "-d", s.dbname, "-f", backup.FileName)
    
    if err := cmd.Run(); err != nil {
        return fmt.Errorf("restore failed: %v", err)
    }
    
    return nil
}
```

**备份策略**：
- 定期自动备份
- 增量备份和全量备份结合
- 备份文件压缩
- 异地备份存储

#### 性能监控

系统监控数据库性能指标：

1. **查询延迟**: 监控慢查询
2. **连接池状态**: 监控连接使用情况
3. **缓存命中率**: 监控查询缓存效果
4. **索引使用率**: 分析索引效率

#### 数据库迁移

系统提供数据库迁移工具：

```bash
# 运行迁移
go run cmd/migrate/main.go up

# 回滚迁移
go run cmd/migrate/main.go down
```

**迁移文件**：
- `scripts/migration_add_user_tables.sql`: 用户表迁移
- `scripts/migration_add_search_indices.sql`: 搜索索引表迁移
- `scripts/migration_add_mcp_tables.sql`: MCP表迁移

---

## integration-minio {#integration-minio}

### MinIO对象存储集成

LAST-doc系统集成了MinIO对象存储服务，提供S3兼容的文件存储能力，支持本地文件系统和分布式存储的无缝切换。

#### 存储服务接口

根据[`internal/service/storage_service.go`](internal/service/storage_service.go)：

```go
// StorageService 存储服务接口
type StorageService interface {
    SaveFile(ctx context.Context, file *multipart.FileHeader, path string) error
    DeleteFile(ctx context.Context, path string) error
    GetFile(ctx context.Context, path string) ([]byte, error)
    GenerateFilePath(documentID, fileName string) string
    FileExists(ctx context.Context, path string) bool
    CopyFile(ctx context.Context, srcPath, dstPath string) error
    MoveFile(ctx context.Context, srcPath, dstPath string) error
    GetFileSize(ctx context.Context, path string) (int64, error)
    GetFileStream(ctx context.Context, path string) (io.ReadCloser, error)
    SaveFileStream(ctx context.Context, path string, reader io.Reader) error
    HealthCheck(ctx context.Context) error
}
```

#### 存储配置

##### 存储类型

```go
// StorageType 存储类型
type StorageType string

const (
    StorageTypeLocal StorageType = "local"
    StorageTypeS3    StorageType = "s3"
    StorageTypeMinIO StorageType = "minio"
)
```

##### 存储配置结构

```go
// StorageConfig 存储配置
type StorageConfig struct {
    Type StorageType
    
    // 本地存储配置
    LocalDir string
    
    // S3配置
    S3Region     string
    S3Bucket     string
    S3AccessKey  string
    S3SecretKey  string
    S3Endpoint   string
    S3DisableSSL bool
    
    // MinIO配置
    MinIOEndpoint  string
    MinIOAccessKey string
    MinIOSecretKey string
    MinIOBucket    string
    MinIOLocation  string
    MinIOUseSSL    bool
}
```

#### 存储工厂

根据[`internal/service/storage_factory.go`](internal/service/storage_factory.go)：

```go
// NewStorageService 根据配置创建存储服务实例
func NewStorageService(config *StorageConfig) (StorageService, error) {
    switch config.Type {
    case StorageTypeLocal:
        return NewLocalStorageService(config.LocalDir), nil
    case StorageTypeS3:
        return NewS3StorageService(config)
    case StorageTypeMinIO:
        return NewS3StorageService(config) // MinIO使用S3兼容模式
    default:
        return NewLocalStorageService(config.LocalDir), nil
    }
}

// NewStorageServiceFromEnv 从环境变量创建存储服务
func NewStorageServiceFromEnv() (StorageService, error) {
    storageTypeStr := getEnv("STORAGE_TYPE", "local")
    storageType := StorageType(storageTypeStr)
    
    config := &StorageConfig{
        Type:           storageType,
        LocalDir:       getEnv("STORAGE_DIR", "./storage"),
        S3Region:       getEnv("S3_REGION", "us-east-1"),
        S3Bucket:       getEnv("S3_BUCKET", ""),
        S3AccessKey:    getEnv("S3_ACCESS_KEY", ""),
        S3SecretKey:    getEnv("S3_SECRET_KEY", ""),
        S3Endpoint:     getEnv("S3_ENDPOINT", ""),
        MinIOEndpoint:  getEnv("MINIO_ENDPOINT", ""),
        MinIOAccessKey: getEnv("MINIO_ACCESS_KEY", ""),
        MinIOSecretKey: getEnv("MINIO_SECRET_KEY", ""),
        MinIOBucket:    getEnv("MINIO_BUCKET", ""),
        MinIOLocation:  getEnv("MINIO_LOCATION", "us-east-1"),
    }
    
    // 根据存储类型设置SSL配置
    if storageType == StorageTypeS3 || storageType == StorageTypeMinIO {
        config.S3DisableSSL = getEnv("S3_DISABLE_SSL", "false") == "true"
        if storageType == StorageTypeMinIO {
            config.MinIOUseSSL = getEnv("MINIO_USE_SSL", "false") == "true"
            // 对于MinIO，使用S3兼容的配置
            config.S3Endpoint = config.MinIOEndpoint
            config.S3AccessKey = config.MinIOAccessKey
            config.S3SecretKey = config.MinIOSecretKey
            config.S3Bucket = config.MinIOBucket
            config.S3Region = config.MinIOLocation
        }
    }
    
    return NewStorageService(config)
}
```

**配置说明**：
- 支持本地、S3和MinIO三种存储类型
- 通过环境变量配置存储参数
- MinIO使用S3兼容API
- 灵活的SSL配置

#### S3存储实现

根据[`internal/service/s3_storage_service.go`](internal/service/s3_storage_service.go)：

##### S3服务结构

```go
// S3StorageService S3存储服务实现
type S3StorageService struct {
    client *s3.S3
    config *StorageConfig
}
```

##### S3客户端初始化

```go
// NewS3StorageService 创建S3存储服务实例
func NewS3StorageService(config *StorageConfig) (*S3StorageService, error) {
    awsConfig := &aws.Config{
        Region:           aws.String(config.S3Region),
        DisableSSL:       aws.Bool(config.S3DisableSSL),
        S3ForcePathStyle: aws.Bool(true),
    }
    
    // 如果提供了自定义endpoint（如MinIO）
    if config.S3Endpoint != "" {
        awsConfig.Endpoint = aws.String(config.S3Endpoint)
    }
    
    // 设置认证
    if config.S3AccessKey != "" && config.S3SecretKey != "" {
        awsConfig.Credentials = credentials.NewStaticCredentials(
            config.S3AccessKey,
            config.S3SecretKey,
            "",
        )
    }
    
    sess, err := session.NewSession(awsConfig)
    if err != nil {
        return nil, fmt.Errorf("failed to create AWS session: %v", err)
    }
    
    return &S3StorageService{
        client: s3.New(sess),
        config: config,
    }, nil
}
```

**初始化特点**：
- 支持自定义endpoint（MinIO兼容）
- 灵活的认证配置
- SSL可配置
- 强制使用路径风格

##### 文件操作

**保存文件**：

```go
// SaveFile 保存文件
func (s *S3StorageService) SaveFile(ctx context.Context, file *multipart.FileHeader, path string) error {
    src, err := file.Open()
    if err != nil {
        return fmt.Errorf("failed to open source file: %v", err)
    }
    defer src.Close()
    
    return s.SaveFileStream(ctx, path, src)
}

// SaveFileStream 保存文件流
func (s *S3StorageService) SaveFileStream(ctx context.Context, path string, reader io.Reader) error {
    _, err := s.client.PutObjectWithContext(ctx, &s3.PutObjectInput{
        Bucket: aws.String(s.config.S3Bucket),
        Key:    aws.String(path),
        Body:   aws.ReadSeekCloser(reader),
    })
    
    if err != nil {
        return fmt.Errorf("failed to upload file to S3: %v", err)
    }
    
    return nil
}
```

**删除文件**：

```go
// DeleteFile 删除文件
func (s *S3StorageService) DeleteFile(ctx context.Context, path string) error {
    _, err := s.client.DeleteObjectWithContext(ctx, &s3.DeleteObjectInput{
        Bucket: aws.String(s.config.S3Bucket),
        Key:    aws.String(path),
    })
    
    if err != nil {
        return fmt.Errorf("failed to delete file from S3: %v", err)
    }
    
    return nil
}
```

**获取文件**：

```go
// GetFile 获取文件内容
func (s *S3StorageService) GetFile(ctx context.Context, path string) ([]byte, error) {
    stream, err := s.GetFileStream(ctx, path)
    if err != nil {
        return nil, err
    }
    defer stream.Close()
    
    return io.ReadAll(stream)
}

// GetFileStream 获取文件流
func (s *S3StorageService) GetFileStream(ctx context.Context, path string) (io.ReadCloser, error) {
    result, err := s.client.GetObjectWithContext(ctx, &s3.GetObjectInput{
        Bucket: aws.String(s.config.S3Bucket),
        Key:    aws.String(path),
    })
    
    if err != nil {
        return nil, fmt.Errorf("failed to get file from S3: %v", err)
    }
    
    return result.Body, nil
}
```

**文件路径生成**：

```go
// GenerateFilePath 生成文件存储路径
func (s *S3StorageService) GenerateFilePath(documentID, fileName string) string {
    // 清理文件名，移除特殊字符
    cleanFileName := strings.Map(func(r rune) rune {
        if r >= 'a' && r <= 'z' || r >= 'A' && r <= 'Z' || r >= '0' && r <= '9' || r == '-' || r == '_' || r == '.' {
            return r
        }
        return '_'
    }, fileName)
    
    return filepath.Join(documentID, cleanFileName)
}
```

**文件存在检查**：

```go
// FileExists 检查文件是否存在
func (s *S3StorageService) FileExists(ctx context.Context, path string) bool {
    _, err := s.client.HeadObjectWithContext(ctx, &s3.HeadObjectInput{
        Bucket: aws.String(s.config.S3Bucket),
        Key:    aws.String(path),
    })
    
    return err == nil
}
```

**文件复制**：

```go
// CopyFile 复制文件
func (s *S3StorageService) CopyFile(ctx context.Context, srcPath, dstPath string) error {
    _, err := s.client.CopyObjectWithContext(ctx, &s3.CopyObjectInput{
        Bucket:     aws.String(s.config.S3Bucket),
        CopySource: aws.String(s.config.S3Bucket + "/" + srcPath),
        Key:        aws.String(dstPath),
    })
    
    if err != nil {
        return fmt.Errorf("failed to copy file in S3: %v", err)
    }
    
    return nil
}
```

**文件移动**：

```go
// MoveFile 移动文件
func (s *S3StorageService) MoveFile(ctx context.Context, srcPath, dstPath string) error {
    // S3中移动文件实际上是复制后删除
    if err := s.CopyFile(ctx, srcPath, dstPath); err != nil {
        return err
    }
    
    return s.DeleteFile(ctx, srcPath)
}
```

**获取文件大小**：

```go
// GetFileSize 获取文件大小
func (s *S3StorageService) GetFileSize(ctx context.Context, path string) (int64, error) {
    result, err := s.client.HeadObjectWithContext(ctx, &s3.HeadObjectInput{
        Bucket: aws.String(s.config.S3Bucket),
        Key:    aws.String(path),
    })
    
    if err != nil {
        return 0, fmt.Errorf("failed to get file size from S3: %v", err)
    }
    
    return *result.ContentLength, nil
}
```

**健康检查**：

```go
// HealthCheck 健康检查
func (s *S3StorageService) HealthCheck(ctx context.Context) error {
    // 通过列出存储桶中的对象来验证连接
    _, err := s.client.ListObjectsV2WithContext(ctx, &s3.ListObjectsV2Input{
        Bucket:  aws.String(s.config.S3Bucket),
        MaxKeys: aws.Int64(1), // 只获取一个对象，避免过多数据传输
    })
    
    if err != nil {
        return fmt.Errorf("S3/MinIO connection failed: %v", err)
    }
    
    return nil
}
```

#### 本地存储实现

系统也提供了本地文件系统存储实现：

```go
// LocalStorageService 本地存储服务实现
type LocalStorageService struct {
    baseDir string
}

// NewLocalStorageService 创建本地存储服务实例
func NewLocalStorageService(baseDir string) *LocalStorageService {
    // 确保基础目录存在
    if err := os.MkdirAll(baseDir, 0755); err != nil {
        panic(fmt.Sprintf("Failed to create base storage directory: %v", err))
    }
    return &LocalStorageService{
        baseDir: baseDir,
    }
}
```

#### 分片上传

虽然当前实现中没有显式的分片上传，但AWS SDK支持分片上传，可以轻松集成：

```go
// 分片上传示例
uploader := s3manager.NewUploader(sess)
input := &s3manager.UploadInput{
    Bucket: aws.String(bucket),
    Key:    aws.String(key),
    Body:   file,
}

result, err := uploader.Upload(input)
```

#### 存储桶管理

系统支持存储桶的自动管理：

1. **自动创建**: 启动时自动创建不存在的存储桶
2. **生命周期管理**: 自动清理过期文件
3. **版本控制**: 支持文件版本控制

#### 访问控制

系统实现了细粒度的访问控制：

1. **存储桶策略**: 基于IAM的访问控制
2. **预签名URL**: 临时访问权限
3. **加密传输**: SSL/TLS加密

#### 签名验证

MinIO支持签名验证，确保请求的安全性：

```go
// 使用临时凭证
creds := credentials.NewStaticCredentials(
    accessKey,
    secretKey,
    token,
)
```

#### 性能优化

1. **连接池**: 重用HTTP连接
2. **并发上传**: 支持多线程上传
3. **断点续传**: 支持分片上传和断点续传
4. **缓存**: 本地缓存热点数据

#### 高可用性

1. **多副本**: 支持数据冗余
2. **纠删码**: 支持容错机制
3. **跨区域复制**: 支持跨区域数据同步

---

## integration-monitoring {#integration-monitoring}

### 监控系统集成

LAST-doc系统集成了Prometheus监控体系，提供全面的系统性能监控和可观测性。

#### Metrics暴露

根据[`internal/handler/metrics_handler.go`](internal/handler/metrics_handler.go)：

##### Metrics定义

```go
var (
    // HTTP 请求总数
    httpRequestsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests.",
        },
        []string{"method", "path", "status"},
    )
    
    // HTTP 请求持续时间
    httpRequestDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "HTTP request duration in seconds.",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "path"},
    )
)

func init() {
    // 注册 metrics
    prometheus.MustRegister(httpRequestsTotal)
    prometheus.MustRegister(httpRequestDuration)
}
```

**Metrics类型**：
- **Counter**: 计数器，单调递增
- **Histogram**: 直方图，记录请求延迟分布
- **Gauge**: 仪表盘，记录瞬时值（如连接数、内存使用）

##### Metrics Handler

```go
// MetricsHandler metrics处理器
type MetricsHandler struct{}

// NewMetricsHandler 创建metrics处理器
func NewMetricsHandler() *MetricsHandler {
    return &MetricsHandler{}
}

// ServeMetrics 暴露 metrics 端点
func (h *MetricsHandler) ServeMetrics(c *gin.Context) {
    promhttp.Handler().ServeHTTP(c.Writer, c.Request)
}

// RecordRequest 记录请求指标
func RecordRequest(method, path string, status int, duration float64) {
    httpRequestsTotal.WithLabelValues(method, path, string(rune(status))).Inc()
    httpRequestDuration.WithLabelValues(method, path).Observe(duration)
}
```

#### 监控指标定义

系统定义了丰富的监控指标：

##### HTTP指标

```go
// 请求总数
http_requests_total{method="GET", path="/api/v1/documents", status="200"}

// 请求延迟
http_request_duration_seconds{method="POST", path="/api/v1/search"}
```

##### 业务指标

```go
// 文档上传数量
document_uploads_total{status="success"}

// 搜索性能
search_duration_seconds{type="keyword|semantic|hybrid"}

// 索引构建时间
index_build_duration_seconds{document_type="pdf|docx|md"}
```

##### 系统指标

```go
// 数据库连接池
db_connections_pool{state="idle|active"}

// 存储使用量
storage_usage_bytes{type="local|s3|minio"}

// 缓存命中率
cache_hit_rate_total{cache="redis"}
```

#### Prometheus配置

参考[`configs/prometheus.yml`](configs/prometheus.yml)：

```yaml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'last-doc'
    static_configs:
      - targets: ['localhost:8080']
        labels:
          service: 'last-doc'
          env: 'production'
```

**配置说明**：
- 采集间隔：15秒
- 评估间隔：15秒
- 目标地址：localhost:8080
- 标签：服务和环境信息

#### Grafana可视化

系统提供Grafana仪表板模板：

##### 仪表板组件

1. **请求量监控**：实时请求流量
2. **响应时间监控**：P50、P95、P99延迟
3. **错误率监控**：HTTP错误码分布
4. **系统资源监控**：CPU、内存、磁盘
5. **业务指标监控**：文档上传、搜索性能

##### 告警规则

```yaml
groups:
  - name: last-doc-alerts
    interval: 30s
    rules:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"
          
      - alert: HighLatency
        expr: histogram_quantile(0.95, http_request_duration_seconds_sum) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High latency detected"
          
      - alert: HighMemoryUsage
        expr: process_resident_memory_bytes / 1024 / 1024 > 1024
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High memory usage detected"
```

#### 系统监控路由

根据[`internal/router/router.go`](internal/router/router.go)：

```go
// 系统监控路由（仅管理员）
monitor := v1.Group("/monitor")
monitor.Use(r.authMiddleware.RequireAuth())  // 需要认证
monitor.Use(r.authMiddleware.RequireAdmin()) // 需要管理员权限
{
    // 获取当前系统指标
    monitor.GET("/metrics/current", r.monitorHandler.GetCurrentMetrics)
    
    // 获取指标历史数据
    monitor.GET("/metrics/history", r.monitorHandler.GetMetricsHistory)
    
    // 获取指标报告
    monitor.GET("/metrics/report", r.monitorHandler.GetMetricsReport)
    
    // 获取系统状态
    monitor.GET("/status", r.monitorHandler.GetSystemStatus)
    
    // 获取日志列表
    monitor.GET("/logs", r.monitorHandler.GetLogs)
    
    // 获取日志统计
    monitor.GET("/logs/stats", r.monitorHandler.GetLogStats)
    
    // 获取性能报告
    monitor.GET("/performance", r.monitorHandler.GetPerformanceReport)
    
    // 清理旧数据
    monitor.POST("/cleanup", r.monitorHandler.CleanupOldData)
}
```

#### 日志记录

系统集成了结构化日志记录：

```go
// LoggingMiddleware 日志记录中间件
func (m *LoggingMiddleware) LogRequest() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        
        // 处理请求
        c.Next()
        
        // 记录请求信息
        duration := time.Since(start)
        log.Printf("%s %s %d %v",
            c.Request.Method,
            c.Request.URL.Path,
            c.Writer.Status(),
            duration,
        )
    }
}
```

#### 分布式追踪

虽然当前实现中没有显式的分布式追踪，但架构支持集成OpenTelemetry：

```go
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// 创建追踪器
tracer := otel.Tracer("last-doc")

// 创建span
ctx, span := tracer.Start(ctx, "process_document")
defer span.End()
```

#### 健康检查

系统提供了多层健康检查：

```go
// 综合健康检查
router.GET("/health", r.healthHandler.CheckHealth)

// 存活探针
router.GET("/health/live", r.healthHandler.LivenessProbe)

// 就绪探针
router.GET("/health/ready", r.healthHandler.ReadinessProbe)

// 熔断器状态
router.GET("/health/circuit-breakers", r.healthHandler.CircuitBreakers)
```

#### 性能分析

系统提供了性能分析工具：

1. **pprof**: CPU和内存分析
2. **trace**: Goroutine追踪
3. **benchmark**: 性能基准测试

#### 监控最佳实践

1. **黄金信号**：延迟、流量、错误、饱和度
2. **RED方法**：请求率、错误率、延迟
3. **USE方法**：利用率、饱和度、错误

---

## extension-plugin {#extension-plugin}

### 插件扩展机制

LAST-doc系统设计了灵活的插件扩展机制，支持动态注册和加载各种解析器、存储插件、认证插件等。

#### 解析器扩展

系统实现了可扩展的文档解析器机制：

##### 解析器接口

```go
// DocumentParser 文档解析器接口
type DocumentParser interface {
    Parse(ctx context.Context, filePath string) (string, map[string]interface{}, error)
    SupportedExtensions() []string
}
```

##### 解析器注册机制

根据[`internal/service/parser_service.go`](internal/service/parser_service.go)：

```go
// parserService 解析服务实现
type parserService struct {
    parsers    map[model.DocumentType]DocumentParser
    grpcClient *GRPCClient
}

// RegisterParser 注册文档解析器
func (s *parserService) RegisterParser(docType model.DocumentType, parser DocumentParser) {
    s.parsers[docType] = parser
}

// NewParserService 创建解析服务实例
func NewParserService() DocumentParserService {
    service := &parserService{
        parsers:    make(map[model.DocumentType]DocumentParser),
        grpcClient: NewGRPCClient(),
    }
    
    // 注册各种文档类型的解析器
    service.RegisterParser(model.DocumentTypeMarkdown, NewMarkdownParser())
    service.RegisterParser(model.DocumentTypeSwagger, NewSwaggerParser())
    service.RegisterParser(model.DocumentTypeOpenAPI, NewOpenAPIParser())
    service.RegisterParser(model.DocumentTypeJavaDoc, NewJavaDocParser())
    
    // 动态注册gRPC解析器或本地解析器
    grpcHost := os.Getenv("GRPC_SERVER_HOST")
    grpcPort := os.Getenv("GRPC_SERVER_PORT")
    
    if grpcHost == "" {
        grpcHost = "localhost"
    }
    if grpcPort == "" {
        grpcPort = "50051"
    }
    
    grpcAddr := grpcHost + ":" + grpcPort
    
    if err := service.grpcClient.Connect(grpcAddr); err != nil {
        fmt.Printf("警告：连接gRPC服务失败(%s)，将使用本地解析器: %v\n", grpcAddr, err)
        service.RegisterParser(model.DocumentTypePDF, NewPDFParser())
        service.RegisterParser(model.DocumentTypeDocx, NewDocxParser())
    } else {
        service.RegisterParser(model.DocumentTypePDF, NewPDFGRPCParser(service.grpcClient))
        service.RegisterParser(model.DocumentTypeDocx, NewDocxGRPCParser(service.grpcClient))
    }
    
    return service
}
```

**扩展特点**：
- 动态注册：运行时注册新解析器
- 接口统一：所有解析器实现相同接口
- 回退机制：支持优雅降级
- 配置驱动：通过环境变量控制

##### 内置解析器

**Markdown解析器**：

```go
type markdownParser struct{}

func (p *markdownParser) Parse(ctx context.Context, filePath string) (string, map[string]interface{}, error) {
    data, err := os.ReadFile(filePath)
    if err != nil {
        return "", nil, fmt.Errorf("failed to read markdown file: %v", err)
    }
    
    content := string(data)
    metadata := extractMarkdownMetadata(content)
    
    return content, metadata, nil
}

func (p *markdownParser) SupportedExtensions() []string {
    return []string{".md", ".markdown"}
}
```

**PDF解析器**：

```go
type pdfParser struct{}

func (p *pdfParser) Parse(ctx context.Context, filePath string) (string, map[string]interface{}, error) {
    data, err := os.ReadFile(filePath)
    if err != nil {
        return "", nil, fmt.Errorf("failed to read PDF file: %v", err)
    }
    
    content := fmt.Sprintf("PDF文档内容（大小：%d字节）", len(data))
    metadata := map[string]interface{}{
        "file_size": len(data),
        "type":      "pdf",
        "pages":     10,
    }
    
    return content, metadata, nil
}

func (p *pdfParser) SupportedExtensions() []string {
    return []string{".pdf"}
}
```

**gRPC解析器**：

```go
// PDF gRPC解析器
type pdfGRPCParser struct {
    client *GRPCClient
}

func NewPDFGRPCParser(client *GRPCClient) DocumentParser {
    return &pdfGRPCParser{client: client}
}

func (p *pdfGRPCParser) Parse(ctx context.Context, filePath string) (string, map[string]interface{}, error) {
    return p.client.ParsePDFWithGRPC(filePath)
}

func (p *pdfGRPCParser) SupportedExtensions() []string {
    return []string{".pdf"}
}
```

#### 存储扩展

系统支持多种存储后端的扩展：

##### 存储接口

```go
// StorageService 存储服务接口
type StorageService interface {
    SaveFile(ctx context.Context, file *multipart.FileHeader, path string) error
    DeleteFile(ctx context.Context, path string) error
    GetFile(ctx context.Context, path string) ([]byte, error)
    GenerateFilePath(documentID, fileName string) string
    FileExists(ctx context.Context, path string) bool
    CopyFile(ctx context.Context, srcPath, dstPath string) error
    MoveFile(ctx context.Context, srcPath, dstPath string) error
    GetFileSize(ctx context.Context, path string) (int64, error)
    GetFileStream(ctx context.Context, path string) (io.ReadCloser, error)
    SaveFileStream(ctx context.Context, path string, reader io.Reader) error
    HealthCheck(ctx context.Context) error
}
```

##### 存储工厂

```go
// NewStorageService 根据配置创建存储服务实例
func NewStorageService(config *StorageConfig) (StorageService, error) {
    switch config.Type {
    case StorageTypeLocal:
        return NewLocalStorageService(config.LocalDir), nil
    case StorageTypeS3:
        return NewS3StorageService(config)
    case StorageTypeMinIO:
        return NewS3StorageService(config)
    default:
        return NewLocalStorageService(config.LocalDir), nil
    }
}
```

**扩展支持**：
- 本地文件系统
- AWS S3
- MinIO
- 可扩展到其他S3兼容存储（如阿里云OSS、腾讯云COS）

#### 认证扩展

系统支持多种认证方式的扩展：

##### 认证接口

```go
// AuthService 认证服务接口
type AuthService interface {
    Authenticate(token string) (*UserClaims, error)
    ValidateJWT(token string) (*UserClaims, error)
    GenerateJWT(user *User) (string, error)
}
```

##### 认证中间件

```go
// RequireAuth 需要认证的中间件
func (m *AuthMiddleware) RequireAuth() gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        // ... 认证逻辑
        c.Next()
    }
}

// APIKeyAuth API密钥认证中间件
func (m *AuthMiddleware) APIKeyAuth() gin.HandlerFunc {
    return func(c *gin.Context) {
        apiKey := c.GetHeader("API_KEY")
        // ... API密钥验证逻辑
        c.Next()
    }
}
```

**支持的认证方式**：
- JWT令牌认证
- API密钥认证
- OAuth2（可扩展）
- LDAP（可扩展）

#### 搜索扩展

系统支持多种搜索算法的扩展：

##### 搜索服务接口

```go
// SearchService 搜索服务接口
type SearchService interface {
    BuildIndex(ctx context.Context, documentID, version string) error
    BuildIndexBatch(ctx context.Context, indices []*model.SearchIndex) error
    Search(ctx context.Context, request *model.SearchRequest) (*model.SearchResponse, error)
    GetIndexingStatus(ctx context.Context, documentID string) (map[string]interface{}, error)
    DeleteIndex(ctx context.Context, documentID string) error
    DeleteIndexByVersion(ctx context.Context, documentID, version string) error
    ClearCache() error
}
```

##### 搜索类型

根据[`internal/service/search_service.go`](internal/service/search_service.go)：

```go
// 根据搜索类型执行不同的搜索策略
switch request.SearchType {
case "keyword":
    keywords := s.extractKeywords(request.Query)
    indices, total, err = s.indexRepo.SearchByKeywords(ctx, keywords, request.Filters, request.Page, request.Size)
    // ... 计算相关性得分
case "semantic":
    queryVector := s.generateQueryVector(request.Query)
    indices, total, err = s.indexRepo.SearchByVector(ctx, queryVector, request.Filters, request.Page, request.Size)
    // ... 计算相关性得分
case "hybrid":
    // 混合搜索：先关键词搜索，再语义搜索，然后合并结果
    // ... 合并结果
default:
    // 默认使用关键词搜索
}
```

**支持的搜索类型**：
- 关键词搜索
- 语义搜索
- 混合搜索
- 可扩展到其他算法（如BM25、TF-IDF）

#### Embedding扩展

系统支持多种Embedding服务的扩展：

##### Embedding接口

```go
// EmbeddingService 嵌入向量服务接口
type EmbeddingService interface {
    GenerateEmbedding(ctx context.Context, content string) ([]float32, error)
}
```

##### 实现类型

**OpenAI实现**：

```go
type openAIEmbeddingService struct {
    client *openai.Client
    model  openai.EmbeddingModel
}
```

**Mock实现**：

```go
type mockEmbeddingService struct{}

func (s *mockEmbeddingService) GenerateEmbedding(ctx context.Context, content string) ([]float32, error) {
    // 生成长度为384的向量
    vector := make([]float32, 384)
    // ... 生成逻辑
    return vector, nil
}
```

**支持的Embedding服务**：
- OpenAI Embedding API
- 本地Mock（用于测试）
- 可扩展到其他服务（如Cohere、HuggingFace）

#### 中间件扩展

系统支持中间件的灵活扩展：

##### 全局中间件

```go
router.Use(gin.Logger())
router.Use(gin.Recovery())
router.Use(middleware.CORS())
router.Use(r.loggingMiddleware.LogRequest())
```

##### 路由中间件

```go
documents.Use(r.authMiddleware.RequireAuth())
monitor.Use(r.authMiddleware.RequireAuth())
monitor.Use(r.authMiddleware.RequireAdmin())
```

**支持的中间件**：
- 日志记录
- 错误恢复
- CORS处理
- 认证授权
- 限流熔断
- 可自定义中间件

#### 插件加载机制

虽然当前实现中没有动态插件加载，但架构支持插件化设计：

1. **接口设计**：定义清晰的插件接口
2. **注册机制**：动态注册插件
3. **配置驱动**：通过配置文件启用/禁用插件
4. **生命周期管理**：插件的初始化和销毁

#### 扩展最佳实践

1. **接口优先**：定义清晰的扩展接口
2. **依赖注入**：使用依赖注入管理插件
3. **配置驱动**：通过配置控制插件行为
4. **错误处理**：完善的错误处理和回退机制
5. **版本兼容**：考虑插件的版本兼容性

#### 未来扩展方向

1. **插件市场**：建立插件生态系统
2. **WebAssembly**：支持WASM插件
3. **微服务**：支持服务化插件
4. **AI插件**：集成AI能力（如翻译、摘要）
5. **工作流**：支持自定义工作流插件

---

## 总结

LAST-doc系统通过完善的集成和扩展机制，提供了强大而灵活的技术架构：

### 核心优势

1. **RESTful API**: 清晰的API设计，完整的中间件支持
2. **gRPC集成**: 高性能的跨语言通信
3. **OpenAI集成**: 先进的语义搜索能力
4. **PostgreSQL集成**: 可靠的数据存储和向量搜索
5. **MinIO集成**: 灵活的文件存储方案
6. **监控集成**: 全面的系统可观测性
7. **插件扩展**: 高度可扩展的架构设计

### 扩展指南

开发者可以通过以下方式扩展系统：

1. **实现接口**: 实现标准的扩展接口
2. **注册插件**: 通过注册机制集成插件
3. **配置启用**: 通过配置文件启用功能
4. **测试验证**: 确保扩展的正确性

系统为未来的技术演进和业务扩展提供了坚实的基础。