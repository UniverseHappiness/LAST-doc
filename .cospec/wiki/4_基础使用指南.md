# 4、基础使用指南

<details>
<summary>相关源文件</summary>
internal/router/router.go
internal/handler/user_handler.go
internal/handler/document_handler.go
internal/handler/search_handler.go
internal/service/user_service.go
internal/service/document_service.go
internal/service/search_service.go
internal/model/user.go
internal/model/document.go
internal/model/search_index.go
internal/middleware/auth.go
web/src/utils/authService.js
web/src/utils/documentService.js
web/src/utils/searchService.js
web/src/composables/useAuth.js
</details>

## 概述

本文档提供了AI技术文档库系统的基础操作指南，帮助用户快速上手使用系统的各项核心功能。系统采用RESTful API架构，支持用户认证、文档管理、智能检索和API调用等功能。通过本指南，用户将掌握从注册登录到文档上传、编辑、检索的完整工作流程，以及如何通过API进行集成开发。

## usage-user-management (用户管理)

### 目的和设计理念

用户管理模块是系统的安全基石，基于JWT（JSON Web Token）认证机制，实现了用户注册、登录、密码重置、个人信息管理等功能。系统采用三层权限模型（admin、editor、user），通过中间件进行细粒度的访问控制，确保数据安全性和操作的规范性。

### 用户注册

用户注册功能允许新用户创建账户，系统会对用户名和邮箱进行唯一性验证，并使用bcrypt算法对密码进行加密存储。

```bash
POST /api/v1/auth/register
Content-Type: application/json

{
  "username": "张三",
  "email": "zhangsan@example.com",
  "password": "password123",
  "first_name": "三",
  "last_name": "张"
}
```

**请求参数说明**：

| 参数 | 类型 | 必填 | 约束 | 说明 |
|------|------|------|------|------|
| username | string | 是 | 3-50字符 | 用户名，全局唯一 |
| email | string | 是 | 邮箱格式 | 邮箱地址，全局唯一 |
| password | string | 是 | 最小6字符 | 用户密码 |
| first_name | string | 是 | 无 | 名 |
| last_name | string | 是 | 无 | 姓 |

**响应示例**：

```json
{
  "message": "注册成功",
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "username": "张三",
    "email": "zhangsan@example.com",
    "role": "user",
    "first_name": "三",
    "last_name": "张",
    "is_active": true
  }
}
```

**注意事项**：
- 用户名和邮箱必须在系统中唯一，注册时会进行验证
- 密码采用bcrypt算法加密，明文密码不会存储到数据库
- 新注册用户默认角色为"user"，账户状态为激活

### 用户登录

用户登录功能支持使用用户名或邮箱进行登录，验证成功后返回访问令牌（access token）和刷新令牌（refresh token）。

```bash
POST /api/v1/auth/login
Content-Type: application/json

{
  "username": "zhangsan@example.com",
  "password": "password123"
}
```

**请求参数说明**：

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| username | string | 是 | 用户名或邮箱 |
| password | string | 是 | 用户密码 |

**响应示例**：

```json
{
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "username": "张三",
    "email": "zhangsan@example.com",
    "role": "user",
    "first_name": "三",
    "last_name": "张",
    "is_active": true
  },
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "a1b2c3d4e5f6...",
  "expires_in": 86400,
  "token_type": "Bearer"
}
```

**JWT认证流程**：

```mermaid
sequenceDiagram
    participant User as 用户
    participant Client as 前端应用
    participant Server as 后端服务
    participant DB as 数据库

    User->>Client: 输入用户名/密码
    Client->>Server: POST /api/v1/auth/login
    Server->>DB: 查询用户信息
    DB-->>Server: 返回用户数据
    Server->>Server: 验证密码(bcrypt)
    Server->>Server: 生成JWT令牌
    Server-->>Client: 返回access_token和refresh_token
    Client->>Client: 保存令牌到localStorage
    Client->>Server: 请求带Authorization: Bearer token
    Server->>Server: 验证JWT有效性
    Server-->>Client: 返回请求结果
```

**令牌使用说明**：
- **access_token**：用于API请求认证，有效期为24小时（可配置）
- **refresh_token**：用于刷新access_token，有效期更长
- 所有需要认证的API请求必须在HTTP Header中携带：`Authorization: Bearer {access_token}`

### 令牌刷新与安全机制

当access_token即将过期时，可以使用refresh_token获取新的access_token，无需重新登录。

**安全设计原理**：

系统采用双令牌机制（access_token + refresh_token），这是 OAuth 2.0 推荐的安全实践：

1. **access_token**：短生命周期（默认24小时），仅用于API认证
2. **refresh_token**：长生命周期，存储在安全的HTTP-only Cookie中，仅用于刷新access_token

**安全优势**：
- 减少令牌泄露风险：即使access_token被窃取，有效期有限
- 避免频繁登录：通过refresh_token无缝续期
- 前端实现简便：refresh_token可自动刷新，用户无感知

**前端自动刷新实现**：

```javascript
// axios拦截器自动处理令牌刷新
axios.interceptors.response.use(
  response => response,
  async error => {
    const originalRequest = error.config;
    
    // 401错误且未重试过
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        // 自动刷新令牌
        const { data } = await axios.post('/api/v1/auth/refresh', {
          refresh_token: getRefreshToken()
        });
        
        // 更新access_token
        setAccessToken(data.access_token);
        
        // 重试原始请求
        originalRequest.headers.Authorization = `Bearer ${data.access_token}`;
        return axios(originalRequest);
      } catch (refreshError) {
        // 刷新失败，跳转登录页
        clearAuthData();
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }
    
    return Promise.reject(error);
  }
);
```

**安全最佳实践**：
- 使用HTTPS传输，防止中间人攻击
- 将refresh_token存储在HTTP-only Cookie中，避免XSS攻击
- 实现令牌黑名单机制，支持强制登出
- 限制refresh_token的使用次数和有效期

```bash
POST /api/v1/auth/refresh
Content-Type: application/json

{
  "refresh_token": "a1b2c3d4e5f6..."
}
```

**响应示例**：

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer"
}
```

### 密码重置

密码重置功能采用邮件验证机制，用户可以通过邮箱请求重置密码，系统会发送包含重置令牌的邮件。

#### 请求密码重置

```bash
POST /api/v1/auth/password/reset-request
Content-Type: application/json

{
  "email": "zhangsan@example.com"
}
```

**响应示例**：

```json
{
  "message": "密码重置邮件已发送"
}
```

#### 重置密码

使用邮件中收到的token进行密码重置。

```bash
POST /api/v1/auth/password/reset
Content-Type: application/json

{
  "token": "reset_token_from_email",
  "password": "newpassword123"
}
```

**响应示例**：

```json
{
  "message": "密码重置成功"
}
```

### 个人信息管理

#### 获取个人信息

```bash
GET /api/v1/users/profile
Authorization: Bearer {access_token}
```

**响应示例**：

```json
{
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "username": "张三",
    "email": "zhangsan@example.com",
    "role": "user",
    "first_name": "三",
    "last_name": "张",
    "avatar": "",
    "is_active": true,
    "last_login": "2024-01-04T15:30:00Z",
    "created_at": "2024-01-01T10:00:00Z",
    "updated_at": "2024-01-04T15:30:00Z"
  }
}
```

#### 更新个人信息

```bash
PUT /api/v1/users/profile
Authorization: Bearer {access_token}
Content-Type: application/json

{
  "email": "newemail@example.com",
  "first_name": "小明",
  "last_name": "李",
  "avatar": "https://example.com/avatar.jpg"
}
```

**响应示例**：

```json
{
  "message": "更新成功",
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "username": "张三",
    "email": "newemail@example.com",
    "first_name": "小明",
    "last_name": "李",
    "avatar": "https://example.com/avatar.jpg"
  }
}
```

**注意事项**：
- 普通用户不能修改角色和账户状态
- 修改邮箱时系统会验证新邮箱的唯一性
- 不允许将邮箱修改为其他用户已使用的邮箱

#### 修改密码

```bash
POST /api/v1/users/change-password
Authorization: Bearer {access_token}
Content-Type: application/json

{
  "old_password": "oldpassword123",
  "new_password": "newpassword456"
}
```

**响应示例**：

```json
{
  "message": "密码修改成功"
}
```

### 权限管理机制

系统采用基于角色的访问控制（RBAC）模型，定义了三种用户角色：

| 角色 | 权限范围 | 说明 |
|------|----------|------|
| admin | 所有权限 | 管理员，可以管理系统所有资源和用户 |
| editor | 文档管理权限 | 编辑，可以上传、编辑、删除文档 |
| user | 基本权限 | 普通用户，可以查看和搜索文档 |

**权限中间件使用**：

后端通过中间件保护需要认证和特定权限的路由：

```go
// 需要认证的路由
users.Use(r.authMiddleware.RequireAuth())

// 需要管理员权限的路由
admin.Use(r.authMiddleware.RequireAdmin())
```

**示例**：
- 获取个人信息：需要认证，所有角色均可访问
- 上传文档：需要认证，editor和admin角色可访问
- 用户管理：需要管理员权限，仅admin角色可访问

## usage-document-upload (文档上传管理)

### 目的和设计理念

文档上传管理模块是系统内容管理的核心，支持多种文档格式（PDF、DOCX、Markdown等）的上传、解析和存储。系统采用异步处理机制，上传后立即返回，后台自动进行文档解析和索引构建，确保用户体验流畅。

### 支持的文档类型

系统支持以下文档类型：

| 文档类型 | 标识 | 支持的文件格式 | 说明 |
|----------|------|----------------|------|
| Markdown | markdown | .md, .markdown | Markdown格式文档 |
| PDF | pdf | .pdf | PDF文档 |
| DOCX | docx | .docx | Word文档 |
| Swagger | swagger | .yaml, .yml | Swagger API文档 |
| OpenAPI | openapi | .yaml, .yml | OpenAPI规范文档 |
| JavaDoc | java_doc | .html, .java | Java技术文档 |

### 文档上传流程

```mermaid
flowchart TD
    A[用户选择文件] --> B[填写文档元数据]
    B --> C[上传文件]
    C --> D{同库文档存在?}
    D -->|否| E[创建新文档记录]
    D -->|是| F[使用现有文档ID]
    E --> G[保存文件到存储]
    F --> G
    G --> H[创建文档版本记录]
    H --> I{版本号唯一?}
    I -->|否| J[返回错误]
    I -->|是| K[异步解析文档]
    K --> L[返回上传成功]
    L --> M[后台处理解析和索引]
```

### 上传文档

```bash
POST /api/v1/documents
Authorization: Bearer {access_token}
Content-Type: multipart/form-data

name: 技术文档示例
type: pdf
category: document
version: 1.0.0
library: tech-docs
description: 这是一份技术文档
tags: 技术,文档,示例
file: [二进制文件数据]
```

**表单字段说明**：

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| name | string | 是 | 文档名称 |
| type | string | 是 | 文档类型（markdown/pdf/docx等） |
| category | string | 是 | 文档分类（code/document） |
| version | string | 是 | 文档版本号 |
| library | string | 是 | 所属库名称 |
| description | string | 否 | 文档描述 |
| tags | string | 否 | 文档标签，逗号分隔（如："tag1,tag2"） |
| file | File | 是 | 上传的文件 |

**响应示例**：

```json
{
  "code": 200,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "技术文档示例",
    "status": "processing"
  },
  "message": "上传成功"
}
```

**文档状态说明**：

| 状态 | 标识 | 说明 |
|------|------|------|
| 上传中 | uploading | 文档正在上传 |
| 处理中 | processing | 文档正在解析和索引 |
| 完成 | completed | 文档处理完成，可搜索 |
| 失败 | failed | 文档处理失败 |

### 文档解析流程

系统会在后台异步处理上传的文档：

1. **文件验证**：检查文件类型是否与指定的文档类型匹配
2. **内容解析**：根据文档类型调用相应的解析器提取文本内容
3. **内容提取**：提取文档的标题、章节、段落等结构化信息
4. **向量生成**：将文档内容转换为向量表示
5. **索引构建**：在搜索索引表中创建索引记录

**解析器服务架构**：

```mermaid
graph TB
    A[上传的文件] --> B[文档解析器服务]
    B --> C{文档类型判断}
    C -->|PDF| D[PDF解析器]
    C -->|DOCX| E[DOCX解析器]
    C -->|Markdown| F[Markdown解析器]
    C -->|其他| G[通用文本解析器]
    D --> H[提取纯文本内容]
    E --> H
    F --> H
    G --> H
    H --> I[向量化服务]
    I --> J[搜索索引服务]
    J --> K[完成索引构建]
```

### 版本管理机制

系统支持同一文档的多个版本：

- **同一库的文档共享相同ID**：相同library名称的文档使用同一个document ID
- **版本号唯一性**：同一文档下的版本号必须唯一
- **独立存储**：每个版本的文件独立存储，互不干扰
- **独立索引**：每个版本独立构建搜索索引

**上传新版本时**：

```bash
POST /api/v1/documents
# 使用相同的library名称
library: tech-docs
# 递增版本号
version: 1.1.0
```

系统会：
1. 检测到现有文档，使用相同的document ID
2. 创建新的文档版本记录
3. 保存新版本的文件到独立路径
4. 为新版本独立构建搜索索引

### 文档元数据管理

#### 获取文档元数据

```bash
GET /api/v1/documents/{document_id}/metadata
Authorization: Bearer {access_token}
```

**响应示例**：

```json
{
  "code": 200,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "document_id": "550e8400-e29b-41d4-a716-446655440000",
    "metadata": {
      "author": "张三",
      "department": "技术部",
      "language": "zh-CN",
      "pages": 45,
      "word_count": 12000
    }
  },
  "message": "获取成功"
}
```

### 文档下载

#### 下载文档

```bash
GET /api/v1/documents/{document_id}/download
Authorization: Bearer {access_token}
```

响应为文件流，可以直接下载或在浏览器中打开。

#### 下载指定版本

```bash
GET /api/v1/documents/{document_id}/versions/{version}/download
Authorization: Bearer {access_token}
```

### 标签管理

标签用于对文档进行分类和快速检索：

**标签设置规则**：
- 支持多个标签，使用逗号分隔
- 标签前后会自动去除空格
- 标签可包含中英文、数字和特殊字符

**标签使用示例**：

```bash
# 上传时设置标签
tags: 技术,文档,API,Java

# 搜索时使用标签过滤
GET /api/v1/documents?tags=技术,API
```

## usage-document-edit (文档编辑与管理)

### 目的和设计理念

文档编辑与管理模块提供文档的全生命周期管理功能，包括文档内容的查看、元数据修改、版本管理、删除等操作。系统采用版本控制机制，支持文档的多版本并存，用户可以灵活管理不同版本的文档。

### 获取文档列表

```bash
GET /api/v1/documents?page=1&size=10&library=tech-docs&type=pdf&status=completed
Authorization: Bearer {access_token}
```

**查询参数说明**：

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| page | int | 否 | 页码，默认1 |
| size | int | 否 | 每页数量，默认10，最大100 |
| library | string | 否 | 所属库名称过滤 |
| type | string | 否 | 文档类型过滤 |
| version | string | 否 | 版本号过滤 |
| status | string | 否 | 文档状态过滤 |
| name | string | 否 | 文档名称模糊搜索 |
| tags | string | 否 | 标签过滤，逗号分隔 |

**响应示例**：

```json
{
  "code": 200,
  "data": {
    "total": 25,
    "items": [
      {
        "id": "550e8400-e29b-41d4-a716-446655440000",
        "name": "技术文档示例",
        "type": "pdf",
        "category": "document",
        "version": "1.0.0",
        "library": "tech-docs",
        "tags": ["技术", "文档"],
        "status": "completed",
        "file_size": 1024000,
        "description": "这是一份技术文档",
        "created_at": "2024-01-01T10:00:00Z",
        "updated_at": "2024-01-04T15:30:00Z",
        "version_count": 3
      }
    ],
    "page": 1,
    "size": 10
  },
  "message": "获取成功"
}
```

### 获取单个文档

```bash
GET /api/v1/documents/{document_id}
Authorization: Bearer {access_token}
```

**响应示例**：

```json
{
  "code": 200,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "技术文档示例",
    "type": "pdf",
    "category": "document",
    "version": "1.0.0",
    "library": "tech-docs",
    "tags": ["技术", "文档"],
    "status": "completed",
    "file_path": "/data/documents/550e8400-e29b-41d4-a716-446655440000/document.pdf",
    "file_size": 1024000,
    "description": "这是一份技术文档",
    "content": "文档的纯文本内容摘要...",
    "created_at": "2024-01-01T10:00:00Z",
    "updated_at": "2024-01-04T15:30:00Z"
  },
  "message": "获取成功"
}
```

**注意**：返回的文档信息默认为最新版本的数据。

### 更新文档

```bash
PUT /api/v1/documents/{document_id}
Authorization: Bearer {access_token}
Content-Type: application/json

{
  "name": "更新后的文档名称",
  "description": "更新后的描述",
  "tags": ["技术", "文档", "更新"]
}
```

**可更新字段**：

| 字段 | 类型 | 说明 |
|------|------|------|
| name | string | 文档名称 |
| description | string | 文档描述 |
| tags | array | 文档标签 |

**响应示例**：

```json
{
  "code": 200,
  "message": "更新成功"
}
```

### 文档版本管理

#### 获取文档版本列表

```bash
GET /api/v1/documents/{document_id}/versions
Authorization: Bearer {access_token}
```

**响应示例**：

```json
{
  "code": 200,
  "data": [
    {
      "id": "version-id-3",
      "document_id": "550e8400-e29b-41d4-a716-446655440000",
      "version": "1.2.0",
      "file_path": "/data/documents/550e8400-e29b-41d4-a716-446655440000/v1.2.0/document.pdf",
      "file_size": 1050000,
      "status": "completed",
      "description": "修复了bug，优化了性能",
      "content": "文档的纯文本内容...",
      "created_at": "2024-01-04T15:30:00Z",
      "updated_at": "2024-01-04T15:30:00Z"
    },
    {
      "id": "version-id-2",
      "document_id": "550e8400-e29b-41d4-a716-446655440000",
      "version": "1.1.0",
      "file_path": "/data/documents/550e8400-e29b-41d4-a716-446655440000/v1.1.0/document.pdf",
      "file_size": 1030000,
      "status": "completed",
      "description": "增加了新功能",
      "content": "文档的纯文本内容...",
      "created_at": "2024-01-03T12:00:00Z",
      "updated_at": "2024-01-03T12:00:00Z"
    },
    {
      "id": "version-id-1",
      "document_id": "550e8400-e29b-41d4-a716-446655440000",
      "version": "1.0.0",
      "file_path": "/data/documents/550e8400-e29b-41d4-a716-446655440000/v1.0.0/document.pdf",
      "file_size": 1024000,
      "status": "completed",
      "description": "初始版本",
      "content": "文档的纯文本内容...",
      "created_at": "2024-01-01T10:00:00Z",
      "updated_at": "2024-01-01T10:00:00Z"
    }
  ],
  "message": "获取成功"
}
```

#### 获取最新版本

```bash
GET /api/v1/documents/{document_id}/versions/latest
Authorization: Bearer {access_token}
```

#### 获取指定版本

```bash
GET /api/v1/documents/{document_id}/versions/{version}
Authorization: Bearer {access_token}
```

#### 更新文档版本

```bash
PUT /api/v1/documents/{document_id}/versions/{version}
Authorization: Bearer {access_token}
Content-Type: application/json

{
  "description": "更新版本的描述信息"
}
```

**响应示例**：

```json
{
  "code": 200,
  "message": "更新成功"
}
```

**注意事项**：
- 版本号不可修改
- 可以更新版本的描述信息
- 不会影响其他版本

#### 删除文档版本

```bash
DELETE /api/v1/documents/{document_id}/versions/{version}
Authorization: Bearer {access_token}
```

**响应示例**：

```json
{
  "code": 200,
  "message": "删除成功"
}
```

**注意事项**：
- 删除版本会同时删除对应的文件
- 删除版本后无法恢复
- 删除最新版本后，系统会自动将倒数第二个版本设为最新版本

### 删除文档

```bash
DELETE /api/v1/documents/{document_id}
Authorization: Bearer {access_token}
```

**响应示例**：

```json
{
  "code": 200,
  "message": "删除成功"
}
```

**删除策略**：
- 删除文档会同时删除所有版本
- 删除文档会同时删除所有版本的搜索索引
- 删除操作不可恢复，请谨慎操作

### 版本回滚

虽然系统不提供直接的版本回滚功能，但可以通过以下方式实现：

1. **重新上传旧版本**：下载需要回滚的版本文件，重新上传为新版本
2. **版本标识**：在版本描述中标识版本类型，如"稳定版v1.0.0"

**示例回滚流程**：

```bash
# 1. 下载需要回滚的版本
GET /api/v1/documents/{document_id}/versions/1.0.0/download

# 2. 重新上传为新版本
POST /api/v1/documents
library: tech-docs
version: 2.0.0  # 递增版本号
description: "回滚到1.0.0稳定版"
file: [下载的文件]
```

### 文档版本对比

系统目前不提供自动化的版本对比功能，但可以通过以下方式实现：

1. **下载两个版本**：分别下载需要对比的版本文件
2. **使用外部工具**：使用专门的文档对比工具（如Beyond Compare、diffmerge等）进行对比
3. **查看版本信息**：通过API获取版本的描述和更新时间等信息

## usage-document-search (文档检索)

### 目的和设计理念

文档检索模块基于向量搜索和传统关键词搜索的混合架构，提供智能、高效的文档检索能力。系统支持关键词搜索、语义搜索和混合搜索三种模式，能够根据用户意图返回最相关的内容。

### 搜索概述

系统提供三种搜索模式：

| 搜索模式 | 说明 | 适用场景 |
|----------|------|----------|
| 关键词搜索 | 基于文档内容的关键词匹配 | 精确查找特定词语或短语 |
| 语义搜索 | 基于向量相似度的语义匹配 | 查找相关主题和概念 |
| 混合搜索 | 结合关键词和语义搜索 | 综合精度和召回率 |

### 关键词搜索

关键词搜索是最基础的搜索方式，直接在文档内容中查找匹配的关键词。

```bash
POST /api/v1/search
Authorization: Bearer {access_token}
Content-Type: application/json

{
  "query": "API接口设计",
  "searchType": "keyword",
  "page": 1,
  "size": 10,
  "filters": {
    "document_id": "550e8400-e29b-41d4-a716-446655440000",
    "version": "1.0.0",
    "content_type": "text"
  }
}
```

**搜索请求参数**：

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| query | string | 是 | 搜索关键词 |
| searchType | string | 是 | 搜索类型（keyword/semantic/hybrid） |
| page | int | 否 | 页码，默认1 |
| size | int | 否 | 每页数量，默认10，最大100 |
| filters | object | 否 | 过滤条件 |

**过滤条件**：

| 过滤条件 | 类型 | 说明 |
|----------|------|------|
| document_id | string | 按文档ID过滤 |
| version | string | 按版本号过滤 |
| content_type | string | 按内容类型过滤（text/code等） |
| section | string | 按文档章节过滤 |

**响应示例**：

```json
{
  "code": 200,
  "data": {
    "total": 15,
    "items": [
      {
        "id": "search-index-id-1",
        "document_id": "550e8400-e29b-41d4-a716-446655440000",
        "version": "1.0.0",
        "title": "技术文档示例",
        "library": "tech-docs",
        "content": "API接口设计的关键点包括...",
        "snippet": "RESTful API接口设计遵循以下原则...",
        "score": 0.95,
        "content_type": "text",
        "section": "API设计",
        "metadata": {
          "author": "张三"
        }
      }
    ],
    "page": 1,
    "size": 10
  },
  "message": "搜索成功"
}
```

### 语义搜索

语义搜索基于向量相似度，能够理解查询的语义含义，返回语义相关的内容，即使没有完全匹配的关键词。

**技术原理**：

语义搜索使用嵌入向量（Embedding）技术实现：

1. **文本向量化**：将文本转换为高维向量（通常为768维或1024维）
2. **向量相似度计算**：使用余弦相似度（Cosine Similarity）计算查询向量与文档向量的相似度
3. **向量索引**：使用pgvector扩展在PostgreSQL中存储和检索向量

**向量嵌入服务架构**：

```mermaid
graph TB
    A[用户查询] --> B[嵌入服务]
    B --> C[查询向量化]
    C --> D[向量数据库]
    D --> E[相似度计算]
    E --> F[Top K结果]
    F --> G[返回搜索结果]
    
    H[文档内容] --> I[文档向量化]
    I --> D
    
    B --> J[OpenAI/GPT]
    B --> K[本地模型]
```

**配置与优化**：

系统支持多种嵌入模型，可根据需求选择：

| 模型类型 | 维度 | 优势 | 适用场景 |
|----------|------|------|----------|
| OpenAI text-embedding-ada-002 | 1536 | 高质量，多语言支持 | 通用场景 |
| text-embedding-3-small | 1536 | 高性价比 | 成本敏感场景 |
| 本地模型（BERT等） | 768 | 无外部依赖，隐私保护 | 私有化部署 |

**性能优化策略**：

1. **向量索引优化**：
```go
// 创建HNSW索引加速向量搜索
CREATE INDEX ON search_indices USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);
```

2. **缓存机制**：热点查询结果缓存到Redis
3. **批量向量化**：多个文档一次性处理，提高吞吐量
4. **异步索引**：文档上传后异步构建向量索引

**使用示例**：

```bash
curl -X POST http://localhost:8080/api/v1/search \
  -H "Authorization: Bearer {access_token}" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "如何设计RESTful API",
    "searchType": "semantic",
    "page": 1,
    "size": 10
  }'
```

**语义搜索优势**：
- 理解查询意图：即使没有精确匹配的关键词也能找到相关内容
- 多语言支持：向量模型支持跨语言检索
- 语义理解：识别同义词、相关概念和相关主题
- 探索性搜索：帮助用户发现未曾想到的相关内容

```bash
POST /api/v1/search
Authorization: Bearer {access_token}
Content-Type: application/json

{
  "query": "如何设计一个优秀的API",
  "searchType": "semantic",
  "page": 1,
  "size": 10
}
```

**语义搜索特点**：
- 支持自然语言查询
- 理解查询意图
- 返回语义相关而非关键词匹配的结果
- 适合探索性搜索和发现相关内容

### 混合搜索

混合搜索结合了关键词搜索和语义搜索的优点，先进行关键词搜索获取精确匹配，再进行语义搜索发现相关内容，最后合并结果并重新排序。

**混合搜索算法原理**：

```mermaid
graph TD
    A[用户查询] --> B[关键词搜索]
    A --> C[语义搜索]
    B --> D[关键词结果集 KR]
    C --> E[语义结果集 SR]
    D --> F[计算关键词得分 ScoreK]
    E --> G[计算语义得分 ScoreS]
    F --> H{结果合并}
    G --> H
    H --> I[去重处理]
    I --> J[加权合并 Score = w1*ScoreK + w2*ScoreS]
    J --> K[重新排序]
    K --> L[返回Top K结果]
    
    style B fill:#e1f5ff
    style C fill:#fff4e1
    style J fill:#ffe1f5
```

**加权策略**：

系统使用可配置的权重策略合并两种搜索结果：

| 搜索类型 | 默认权重 | 权重范围 | 说明 |
|----------|----------|----------|------|
| 关键词搜索 | 0.6 | 0.0-1.0 | 精确匹配的权重 |
| 语义搜索 | 0.4 | 0.0-1.0 | 语义相关的权重 |

**权重配置示例**：

```javascript
// 前端配置混合搜索权重
const searchConfig = {
  hybridWeights: {
    keyword: 0.6,  // 关键词权重60%
    semantic: 0.4   // 语义权重40%
  }
};

// 根据场景调整权重
const precisionConfig = {
  hybridWeights: {
    keyword: 0.8,  // 提高精度，降低召回
    semantic: 0.2
  }
};

const recallConfig = {
  hybridWeights: {
    keyword: 0.4,  // 提高召回，降低精度
    semantic: 0.6
  }
};
```

**使用场景建议**：

| 场景 | 推荐权重比例 | 理由 |
|------|--------------|------|
| 技术文档精确查询 | 关键词0.8，语义0.2 | 用户清楚知道要找什么 |
| 知识探索 | 关键词0.4，语义0.6 | 发现相关内容，扩大搜索范围 |
| 综合场景 | 关键词0.6，语义0.4 | 平衡精度和召回率 |

**性能优化**：

混合搜索由于需要执行两次查询，性能会比单一搜索模式略慢。优化策略：

1. **并行查询**：关键词搜索和语义搜索并行执行
2. **缓存优化**：分别缓存两种搜索的结果
3. **结果集限制**：每种搜索只返回Top N结果，减少合并开销
4. **增量更新**：对频繁查询的结果使用增量更新策略

```go
// 后端并行执行混合搜索
func (s *searchService) hybridSearch(ctx context.Context, query string) ([]*SearchIndex, error) {
    var (
        keywordResults []*SearchIndex
        semanticResults []*SearchIndex
        wg sync.WaitGroup
        errKeyword error
        errSemantic error
    )
    
    // 并行执行
    wg.Add(2)
    go func() {
        defer wg.Done()
        keywordResults, errKeyword = s.keywordSearch(ctx, query)
    }()
    
    go func() {
        defer wg.Done()
        semanticResults, errSemantic = s.semanticSearch(ctx, query)
    }()
    
    wg.Wait()
    
    // 合并结果
    return s.mergeResults(keywordResults, semanticResults)
}
```

**混合搜索使用示例**：

```bash
POST /api/v1/search
Authorization: Bearer {access_token}
Content-Type: application/json

{
  "query": "API设计最佳实践",
  "searchType": "hybrid",
  "page": 1,
  "size": 10
}
```

**混合搜索流程图**：

```mermaid
flowchart TD
    A[用户搜索查询] --> B[关键词搜索]
    A --> C[语义搜索]
    B --> D[关键词结果集]
    C --> E[语义结果集]
    D --> F[计算相关性得分]
    E --> G[计算相关性得分]
    F --> H[合并和去重]
    G --> H
    H --> I[重新排序]
    I --> J[返回最终结果]
```

### GET方式搜索

系统也支持通过GET方式进行简单搜索：

```bash
GET /api/v1/search?query=API设计&search_type=keyword&page=1&size=10&document_id=xxx
Authorization: Bearer {access_token}
```

**GET参数说明**：

| 参数 | 类型 | 说明 |
|------|------|------|
| query | string | 搜索关键词 |
| search_type | string | 搜索类型，默认keyword |
| page | int | 页码，默认1 |
| size | int | 每页数量，默认10 |
| document_id | string | 按文档ID过滤 |
| version | string | 按版本号过滤 |
| content_type | string | 按内容类型过滤 |
| section | string | 按文档章节过滤 |

### 搜索结果排序

搜索结果按照相关性得分（score）进行排序：

- **score范围**：0.0-1.0
- **得分越高**：相关性越强
- **排序规则**：从高到低排序

**相关性计算因素**：
- 关键词匹配度
- 语义相似度
- 内容长度
- 更新时间

### 高级搜索技巧

#### 1. 组合过滤

通过组合多个过滤条件实现精确查找：

```json
{
  "query": "API",
  "filters": {
    "document_id": "550e8400-e29b-41d4-a716-446655440000",
    "version": "1.0.0",
    "content_type": "text",
    "section": "API设计"
  }
}
```

#### 2. 分页浏览

对于大量搜索结果，使用分页功能：

- 初始搜索：设置较小的page和size，快速查看结果
- 翻页查看：逐步增加page值，浏览更多结果

#### 3. 搜索策略选择

根据不同场景选择合适的搜索模式：

| 场景 | 推荐搜索模式 | 理由 |
|------|--------------|------|
| 查找特定术语 | keyword | 精确匹配，结果可靠 |
| 探索相关主题 | semantic | 发现语义相关的内容 |
| 综合查询 | hybrid | 平衡精度和召回率 |

#### 4. 查询优化

- **使用具体术语**：避免过于宽泛的查询词
- **组合多个关键词**：提高搜索精确度
- **使用过滤条件**：缩小搜索范围
- **选择合适的搜索模式**：根据查询意图

### 搜索索引管理

#### 构建文档索引

```bash
POST /api/v1/search/documents/{document_id}/versions/{version}/index
Authorization: Bearer {access_token}
```

**响应示例**：

```json
{
  "code": 200,
  "message": "索引构建成功"
}
```

**索引构建条件**：
- 文档状态必须为"completed"
- 文档内容必须已解析完成

#### 获取索引状态

```bash
GET /api/v1/search/documents/{document_id}/index/status
Authorization: Bearer {access_token}
```

**响应示例**：

```json
{
  "code": 200,
  "data": {
    "document_id": "550e8400-e29b-41d4-a716-446655440000",
    "total_indexes": 5,
    "indexed_versions": ["1.0.0", "1.1.0", "1.2.0"],
    "unindexed_versions": [],
    "last_indexed_at": "2024-01-04T15:30:00Z"
  },
  "message": "获取成功"
}
```

#### 删除索引

**删除文档的所有索引**：

```bash
DELETE /api/v1/search/documents/{document_id}/index
Authorization: Bearer {access_token}
```

**删除指定版本的索引**：

```bash
DELETE /api/v1/search/documents/{document_id}/versions/{version}/index
Authorization: Bearer {access_token}
```

**使用场景**：
- 文档内容更新后需要重新索引
- 索引损坏或错误时需要重建
- 清理不需要的索引以节省存储空间

### 搜索最佳实践

1. **从简单查询开始**：先使用关键词搜索，根据结果调整查询策略
2. **善用过滤条件**：在已知文档属性时使用过滤条件提高效率
3. **选择合适的搜索模式**：
   - 精确查找：使用keyword
   - 探索相关：使用semantic
   - 综合查询：使用hybrid
4. **关注相关性得分**：优先查看得分高的结果
5. **利用分页功能**：合理设置每页数量，避免返回过多结果
6. **定期维护索引**：确保文档索引的及时更新

## usage-api-usage (API使用指南)

### 目的和设计理念

API使用指南为开发者提供了完整的RESTful API使用说明，包括API密钥管理、认证方式、请求格式、响应格式、错误码说明，以及常用的API调用示例，帮助开发者快速集成和使用AI技术文档库系统。

### API概述

AI技术文档库系统提供完整的RESTful API，支持以下功能类别：

| API类别 | 基础路径 | 说明 |
|---------|----------|------|
| 文档管理 | /api/v1/documents | 文档上传、查询、编辑、删除 |
| 文档搜索 | /api/v1/search | 关键词搜索、语义搜索、混合搜索 |
| 用户认证 | /api/v1/auth | 用户注册、登录、密码重置 |
| 用户管理 | /api/v1/users | 个人信息管理、用户管理 |
| AI格式 | /api/v1/ai-format | AI友好格式生成 |
| MCP协议 | /api/v1/mcp | MCP协议支持 |
| 系统监控 | /api/v1/monitor | 系统监控（管理员） |
| 备份管理 | /api/v1/backup | 备份管理（管理员） |

### API认证方式

#### JWT认证（推荐）

大多数API需要JWT认证，在HTTP Header中携带访问令牌。

**请求格式**：

```http
GET /api/v1/documents
Authorization: Bearer {access_token}
Content-Type: application/json
```

**令牌获取流程**：

```bash
# 1. 用户登录获取令牌
POST /api/v1/auth/login
{
  "username": "user@example.com",
  "password": "password"
}

# 响应中包含access_token
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 86400
}

# 2. 在后续请求中使用令牌
GET /api/v1/documents
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

#### API密钥认证（可选）

某些API（如MCP协议）支持API密钥认证。

**请求格式**：

```http
GET /api/v1/mcp/config
API_KEY: {your_api_key}
```

或者：

```http
GET /api/v1/mcp/config
Authorization: Bearer {your_api_key}
```

**API密钥管理**：

```bash
# 创建API密钥（需要认证）
POST /api/v1/mcp/keys
Authorization: Bearer {access_token}
{
  "name": "我的API密钥",
  "description": "用于MCP协议访问"
}

# 获取API密钥列表
GET /api/v1/mcp/keys
Authorization: Bearer {access_token}

# 删除API密钥
DELETE /api/v1/mcp/keys/{key_id}
Authorization: Bearer {access_token}
```

### API请求格式

#### 请求方法

系统使用标准HTTP方法表示操作类型：

| 方法 | 说明 | 示例 |
|------|------|------|
| GET | 获取资源 | GET /api/v1/documents |
| POST | 创建资源 | POST /api/v1/documents |
| PUT | 更新资源 | PUT /api/v1/documents/{id} |
| DELETE | 删除资源 | DELETE /api/v1/documents/{id} |

#### 请求头

常用的请求头：

| 请求头 | 值 | 说明 |
|--------|-----|------|
| Authorization | Bearer {token} | JWT认证或API密钥 |
| Content-Type | application/json | JSON格式请求体 |
| Content-Type | multipart/form-data | 文件上传 |

#### 请求体

大多数POST和PUT请求需要JSON格式的请求体：

```json
{
  "field1": "value1",
  "field2": "value2",
  "nested": {
    "sub_field": "sub_value"
  }
}
```

**文件上传使用multipart/form-data**：

```http
POST /api/v1/documents
Content-Type: multipart/form-data

name=文档名称&type=pdf&file=[binary_data]
```

### API响应格式

#### 统一响应结构

所有API响应遵循统一的JSON格式：

```json
{
  "code": 200,
  "data": {
    // 响应数据
  },
  "message": "操作成功"
}
```

**响应字段说明**：

| 字段 | 类型 | 说明 |
|------|------|------|
| code | int | 业务状态码 |
| data | object/array | 响应数据 |
| message | string | 响应消息 |

#### HTTP状态码

系统使用标准HTTP状态码表示请求结果：

| 状态码 | 说明 | 使用场景 |
|--------|------|----------|
| 200 | OK | 请求成功 |
| 201 | Created | 资源创建成功 |
| 400 | Bad Request | 请求参数错误 |
| 401 | Unauthorized | 未授权或令牌无效 |
| 403 | Forbidden | 权限不足 |
| 404 | Not Found | 资源不存在 |
| 500 | Internal Server Error | 服务器内部错误 |

#### 业务状态码

业务状态码（code字段）用于表示业务操作结果：

| code | message | 说明 |
|------|---------|------|
| 200 | 操作成功 | 请求成功完成 |
| 400 | 请求参数错误 | 参数验证失败 |
| 401 | 未授权访问 | 认证失败 |
| 403 | 权限不足 | 权限验证失败 |
| 404 | 资源不存在 | 查询的资源不存在 |
| 500 | 操作失败 | 服务器处理失败 |

### 错误处理

#### 错误响应格式

错误时的响应格式：

```json
{
  "code": 400,
  "error": "请求参数错误",
  "details": "文档名称不能为空"
}
```

#### 常见错误码

| 错误类型 | HTTP状态码 | 错误信息 | 解决方案 |
|----------|------------|----------|----------|
| 参数错误 | 400 | 无效的请求参数 | 检查请求参数格式和内容 |
| 认证失败 | 401 | 无效的授权令牌 | 重新获取access_token |
| 权限不足 | 403 | 权限不足 | 检查用户角色和所需权限 |
| 资源不存在 | 404 | 资源不存在 | 确认资源ID是否正确 |
| 文件上传失败 | 500 | 上传文档失败 | 检查文件格式和大小限制 |
| 搜索失败 | 500 | 搜索失败 | 检查搜索参数和索引状态 |

### 常用API调用示例

#### 1. 文档管理

**上传文档**：

```bash
curl -X POST http://localhost:8080/api/v1/documents \
  -H "Authorization: Bearer {access_token}" \
  -F "name=技术文档" \
  -F "type=pdf" \
  -F "category=document" \
  -F "version=1.0.0" \
  -F "library=tech-docs" \
  -F "description=技术文档描述" \
  -F "tags=技术,文档" \
  -F "file=@document.pdf"
```

**获取文档列表**：

```bash
curl -X GET "http://localhost:8080/api/v1/documents?page=1&size=10&status=completed" \
  -H "Authorization: Bearer {access_token}"
```

**获取文档详情**：

```bash
curl -X GET http://localhost:8080/api/v1/documents/{document_id} \
  -H "Authorization: Bearer {access_token}"
```

**更新文档**：

```bash
curl -X PUT http://localhost:8080/api/v1/documents/{document_id} \
  -H "Authorization: Bearer {access_token}" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "更新后的文档名称",
    "description": "更新后的描述"
  }'
```

**删除文档**：

```bash
curl -X DELETE http://localhost:8080/api/v1/documents/{document_id} \
  -H "Authorization: Bearer {access_token}"
```

#### 2. 文档搜索

**关键词搜索**：

```bash
curl -X POST http://localhost:8080/api/v1/search \
  -H "Authorization: Bearer {access_token}" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "API接口设计",
    "searchType": "keyword",
    "page": 1,
    "size": 10
  }'
```

**语义搜索**：

```bash
curl -X POST http://localhost:8080/api/v1/search \
  -H "Authorization: Bearer {access_token}" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "如何设计好的API",
    "searchType": "semantic",
    "page": 1,
    "size": 10
  }'
```

**混合搜索**：

```bash
curl -X POST http://localhost:8080/api/v1/search \
  -H "Authorization: Bearer {access_token}" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "API设计最佳实践",
    "searchType": "hybrid",
    "page": 1,
    "size": 10,
    "filters": {
      "document_id": "550e8400-e29b-41d4-a716-446655440000"
    }
  }'
```

**GET方式搜索**：

```bash
curl -X GET "http://localhost:8080/api/v1/search?query=API&search_type=keyword&page=1&size=10" \
  -H "Authorization: Bearer {access_token}"
```

#### 3. 用户认证

**用户注册**：

```bash
curl -X POST http://localhost:8080/api/v1/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "zhangsan",
    "email": "zhangsan@example.com",
    "password": "password123",
    "first_name": "三",
    "last_name": "张"
  }'
```

**用户登录**：

```bash
curl -X POST http://localhost:8080/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "zhangsan@example.com",
    "password": "password123"
  }'
```

**刷新令牌**：

```bash
curl -X POST http://localhost:8080/api/v1/auth/refresh \
  -H "Content-Type: application/json" \
  -d '{
    "refresh_token": "refresh_token_value"
  }'
```

#### 4. 用户管理

**获取个人信息**：

```bash
curl -X GET http://localhost:8080/api/v1/users/profile \
  -H "Authorization: Bearer {access_token}"
```

**更新个人信息**：

```bash
curl -X PUT http://localhost:8080/api/v1/users/profile \
  -H "Authorization: Bearer {access_token}" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "newemail@example.com",
    "first_name": "小明",
    "last_name": "李"
  }'
```

**修改密码**：

```bash
curl -X POST http://localhost:8080/api/v1/users/change-password \
  -H "Authorization: Bearer {access_token}" \
  -H "Content-Type: application/json" \
  -d '{
    "old_password": "oldpassword",
    "new_password": "newpassword"
  }'
```

#### 5. 文档版本管理

**获取文档版本列表**：

```bash
curl -X GET http://localhost:8080/api/v1/documents/{document_id}/versions \
  -H "Authorization: Bearer {access_token}"
```

**获取最新版本**：

```bash
curl -X GET http://localhost:8080/api/v1/documents/{document_id}/versions/latest \
  -H "Authorization: Bearer {access_token}"
```

**更新文档版本**：

```bash
curl -X PUT http://localhost:8080/api/v1/documents/{document_id}/versions/{version} \
  -H "Authorization: Bearer {access_token}" \
  -H "Content-Type: application/json" \
  -d '{
    "description": "更新版本描述"
  }'
```

**删除文档版本**：

```bash
curl -X DELETE http://localhost:8080/api/v1/documents/{document_id}/versions/{version} \
  -H "Authorization: Bearer {access_token}"
```

#### 6. 索引管理

**构建文档索引**：

```bash
curl -X POST http://localhost:8080/api/v1/search/documents/{document_id}/versions/{version}/index \
  -H "Authorization: Bearer {access_token}"
```

**获取索引状态**：

```bash
curl -X GET http://localhost:8080/api/v1/search/documents/{document_id}/index/status \
  -H "Authorization: Bearer {access_token}"
```

**删除索引**：

```bash
curl -X DELETE http://localhost:8080/api/v1/search/documents/{document_id}/index \
  -H "Authorization: Bearer {access_token}"
```

### API开发最佳实践

#### 1. 认证管理

- **安全存储令牌**：不要在代码中硬编码令牌，使用环境变量或密钥管理服务
- **定期刷新令牌**：在access_token过期前使用refresh_token刷新
- **错误处理**：处理401错误时自动尝试刷新令牌

#### 2. 错误处理

- **检查HTTP状态码**：根据HTTP状态码判断请求是否成功
- **解析错误信息**：根据响应中的error和details字段分析错误原因
- **重试机制**：对于网络错误或服务器错误，实现自动重试机制
- **日志记录**：记录API请求和响应，便于问题排查

#### 3. 性能优化

- **分页查询**：对于大量数据，使用分页功能避免返回过多数据
- **使用过滤条件**：尽量使用过滤条件缩小查询范围
- **缓存机制**：对频繁访问的数据实现客户端缓存
- **并发请求**：对于独立操作，使用并发请求提高效率

#### 4. 数据验证

- **验证响应数据**：不要盲信任API返回的数据，进行必要的验证
- **处理空值**：处理可能为空的字段，避免空指针异常
- **类型转换**：确保数据类型转换的安全性

### API集成示例（JavaScript）

```javascript
import axios from 'axios';

// API基础配置
const api = axios.create({
  baseURL: 'http://localhost:8080/api/v1',
  timeout: 10000
});

// 请求拦截器：添加认证令牌
api.interceptors.request.use(config => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 响应拦截器：处理错误和令牌刷新
api.interceptors.response.use(
  response => response.data,
  async error => {
    const originalRequest = error.config;
    
    // 如果是401错误且未尝试过刷新令牌
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        // 刷新令牌
        const refreshToken = localStorage.getItem('refreshToken');
        const response = await axios.post('http://localhost:8080/api/v1/auth/refresh', {
          refresh_token: refreshToken
        });
        
        // 保存新令牌
        localStorage.setItem('token', response.data.access_token);
        
        // 重试原始请求
        originalRequest.headers.Authorization = `Bearer ${response.data.access_token}`;
        return api(originalRequest);
      } catch (refreshError) {
        // 刷新失败，清除登录信息
        localStorage.removeItem('token');
        localStorage.removeItem('refreshToken');
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }
    
    return Promise.reject(error);
  }
);

// 使用示例
export async function searchDocuments(query, searchType = 'keyword') {
  try {
    const response = await api.post('/search', {
      query,
      searchType,
      page: 1,
      size: 10
    });
    return response.data;
  } catch (error) {
    console.error('搜索失败:', error);
    throw error;
  }
}
```

### API版本管理

当前API版本为`v1`，所有API路径都包含版本前缀：`/api/v1`

**版本兼容性**：
- 系统会保持当前主版本（v1）的向后兼容性
- 新增功能会通过小版本迭代加入
- 废弃的功能会提前通知，并提供迁移指南

### 系统架构概览

**完整系统架构**：

```mermaid
graph TB
    subgraph "客户端层"
        A1[Web浏览器]
        A2[API客户端]
        A3[MCP客户端]
    end
    
    subgraph "负载均衡层"
        B[Nginx/Gateway]
    end
    
    subgraph "应用层"
        C1[后端服务集群]
        C2[文档解析服务]
        C3[嵌入服务]
    end
    
    subgraph "数据层"
        D1[(PostgreSQL)]
        D2[(Redis缓存)]
        D3[MinIO对象存储]
    end
    
    subgraph "监控层"
        E1[Prometheus]
        E2[Grafana]
    end
    
    A1 --> B
    A2 --> B
    A3 --> B
    B --> C1
    C1 --> D1
    C1 --> D2
    C1 --> D3
    C1 --> C2
    C1 --> C3
    C1 --> E1
    E1 --> E2
```

**分层架构说明**：

| 层级 | 组件 | 技术栈 | 职责 |
|------|------|--------|------|
| 客户端层 | Web前端、API客户端 | Vue.js, Axios | 用户界面和API调用 |
| 负载均衡层 | Nginx | Nginx | 请求路由、负载均衡、TLS终止 |
| 应用层 | 后端服务、解析服务 | Go, gRPC | 业务逻辑处理、文档解析、向量生成 |
| 数据层 | 数据库、缓存、存储 | PostgreSQL, Redis, MinIO | 数据持久化、缓存加速、文件存储 |
| 监控层 | 监控和可视化 | Prometheus, Grafana | 系统监控、性能分析、告警 |

**技术栈说明**：

1. **后端技术栈**：
   - **Go语言**：高性能、并发处理能力强
   - **Gin框架**：轻量级Web框架
   - **GORM**：ORM框架，简化数据库操作
   - **gRPC**：高性能RPC框架，用于微服务通信

2. **数据存储技术栈**：
   - **PostgreSQL + pgvector**：关系型数据库，支持向量搜索
   - **Redis**：内存数据库，用于缓存和会话管理
   - **MinIO**：对象存储，用于文档文件存储

3. **前端技术栈**：
   - **Vue.js 3**：渐进式JavaScript框架
   - **Axios**：HTTP客户端，用于API调用
   - **Vite**：前端构建工具

**跨层级通信流程**：

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant Nginx as 负载均衡
    participant Backend as 后端服务
    participant Parse as 解析服务
    participant Embed as 嵌入服务
    participant DB as PostgreSQL
    participant Cache as Redis
    participant Storage as MinIO
    
    Client->>Nginx: HTTPS请求
    Nginx->>Backend: 转发请求（HTTP）
    
    alt 文档上传
        Backend->>Storage: 保存文件
        Backend->>Parse: 解析文档（gRPC）
        Parse-->>Backend: 返回文本内容
        Backend->>Embed: 生成向量（gRPC）
        Embed-->>Backend: 返回向量
        Backend->>DB: 存储元数据
        Backend->>DB: 存储向量索引
    else 文档搜索
        Backend->>Cache: 检查缓存
        alt 缓存命中
            Cache-->>Backend: 返回缓存结果
        else 缓存未命中
            Backend->>Embed: 查询向量化
            Embed-->>Backend: 返回查询向量
            Backend->>DB: 向量相似度搜索
            DB-->>Backend: 返回搜索结果
            Backend->>Cache: 写入缓存
        end
    end
    
    Backend-->>Nginx: 响应数据
    Nginx-->>Client: HTTPS响应
```

## 总结

本指南详细介绍了AI技术文档库系统的基础使用方法，包括用户管理、文档上传管理、文档编辑与管理、文档检索和API使用指南。通过本指南，用户可以：

1. **快速上手**：掌握用户注册、登录、令牌使用等基本操作
2. **文档管理**：学会上传、编辑、删除文档，以及版本管理
3. **智能检索**：使用关键词搜索、语义搜索和混合搜索找到所需内容
4. **API集成**：通过RESTful API将系统集成到现有应用中

如需更多技术细节，请参考项目文档的其他章节或联系技术支持团队。